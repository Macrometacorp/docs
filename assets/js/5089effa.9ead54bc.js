"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[36542],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(a),h=r,u=d["".concat(s,".").concat(h)]||d[h]||m[h]||l;return a?n.createElement(u,i(i({ref:t},c),{},{components:a})):n.createElement(u,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},906:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const l={sidebar_position:40,title:"Search Patterns"},i=void 0,o={unversionedId:"search/patterns",id:"search/patterns",title:"Search Patterns",description:"In today's world, a fundamental requirement for running a successful business is to be able to quickly and accurately locate certain information from large data repositories. This is called indexing and searching.",source:"@site/docs/search/patterns.md",sourceDirName:"search",slug:"/search/patterns",permalink:"/docs/search/patterns",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/search/patterns.md",tags:[],version:"current",sidebarPosition:40,frontMatter:{sidebar_position:40,title:"Search Patterns"},sidebar:"defaultSidebar",previous:{title:"Analyzers",permalink:"/docs/search/analyzers"},next:{title:"Graphs",permalink:"/docs/graphs/"}},s={},p=[{value:"Example Dataset",id:"example-dataset",level:2},{value:"Patterns",id:"patterns",level:2},{value:"Exact Value Matching",id:"exact-value-matching",level:3},{value:"Matching with Negations",id:"matching-with-negations",level:4},{value:"Matching Multiple Strings",id:"matching-multiple-strings",level:4},{value:"Prefix Matching",id:"prefix-matching",level:3},{value:"Range Queries",id:"range-queries",level:3},{value:"Comparing to a Number",id:"comparing-to-a-number",level:4},{value:"Comparing to a Numeric Range",id:"comparing-to-a-numeric-range",level:4},{value:"Comparing Strings",id:"comparing-strings",level:4},{value:"Full-text Token Search",id:"full-text-token-search",level:2},{value:"Token Search",id:"token-search",level:3},{value:"Phrase and Proximity Search",id:"phrase-and-proximity-search",level:2},{value:"Faceted Search",id:"faceted-search",level:2},{value:"Geospatial Search",id:"geospatial-search",level:2},{value:"Geospatial Datasets",id:"geospatial-datasets",level:3}],c={toc:p};function m(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In today's world, a fundamental requirement for running a successful business is to be able to quickly and accurately locate certain information from large data repositories. This is called ",(0,r.kt)("em",{parentName:"p"},"indexing")," and ",(0,r.kt)("em",{parentName:"p"},"searching"),"."),(0,r.kt)("p",null,"GDN brings two main advantages over other data stores:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GDN is equipped with a state-of-the-art indexing and search facility that enables users to perform sophisticated search operations on ",(0,r.kt)("a",{parentName:"li",href:"https://www.macrometa.com/topics/multi-model-database"},"multi-model")," data storage including key-value pairs, documents, and graphs.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"You do not need to reformat data to make it compatible with GDN search."),(0,r.kt)("li",{parentName:"ul"},"GDN search is capable of complex operations such as faceted search and geospatial serach."))),(0,r.kt)("li",{parentName:"ul"},"Any time we update Macrometa GDN, ",(0,r.kt)("a",{parentName:"li",href:"/docs/search/views/"},"search indexes")," are automatically updated globally.")),(0,r.kt)("p",null,"This page provides detailed examples of possible search query patterns. All examples use the GDN Web console and HTTP REST API."),(0,r.kt)("h2",{id:"example-dataset"},"Example Dataset"),(0,r.kt)("p",null,"This example uses the London-based hotel reviews ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Macrometacorp/datasets/blob/master/hotel-reviews/hotels.json"},"dataset")," obtained from ",(0,r.kt)("a",{parentName:"p",href:"https://www.kaggle.com/PromptCloudHQ/reviews-of-londonbased-hotels"},"Kaggle"),". The refined dataset has 10,000 reviews collected from a travel portal."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Schema of a hotel review",src:a(67383).Z,width:"1083",height:"194"})),(0,r.kt)("p",null,"You can download the dataset from the ",(0,r.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/Macrometacorp/datasets/master/hotel-reviews/hotels.json"},"Macrometa dataset repository"),". After downloading the JSON file, copy its content between the empty array definition of the data item in the following command. The dataset can be imported to your GDN federation by using the cURL command on a terminal as shown in the following example. "),(0,r.kt)("p",null,"Before running the example cURL, create a fabric named ",(0,r.kt)("em",{parentName:"p"},"Hotels")," in your GDN federation and then create a document collection called ",(0,r.kt)("em",{parentName:"p"},"hotel","_","reviews")," within that fabric."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'https://<HOST>/_fabric/Hotels/_api/import/hotel_reviews\' \\\n--header \'accept: application/json\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--header \'Content-Type: text/plain\' \\\n--data-raw \'{\n  "data": [{\n    "Property Name": "The Savoy",\n    "Review Rating": 5,\n    "Review Title": "a legend",\n    "Review Text": "We stayed in May during a short family vacation. Location is perfect to explore all the London sights. Service and facilities are impeccable. The hotel staff was very nicely taking care of our kids. We\'ll be back for sure!",\n    "Location Of The Reviewer": "Oslo, Norway",\n    "Date Of Review": "6\\/28\\/2018"\n}],\n  "details": false,\n  "primaryKey": "",\n  "replace": false\n}\'\n')),(0,r.kt)("h2",{id:"patterns"},"Patterns"),(0,r.kt)("p",null,"This section lists different search patterns that are frequently found in GDN."),(0,r.kt)("h3",{id:"exact-value-matching"},"Exact Value Matching"),(0,r.kt)("p",null,"In the most basic version of search is to match the presence of an exact value. The exact value can be either strings, numbers, number ranges, or booleans. Here we can index and search strings using an identity analyzer. "),(0,r.kt)("p",null,"The view used for exact value matching can be defined as shown in the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request PUT \'https://<HOST>/_fabric/Hotels/_api/search/view/sample1_view1/properties\' \\\n--header \'Content-Type: application/json\' \\\n--header \'Accept: application/json\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--data-raw \'{\n   "links": {\n       "hotel_reviews": {\n           "analyzers": [\n               "identity"\n           ],\n           "fields": {\n            "Property_Name": {}\n           },\n           "includeAllFields": true,\n           "storeValues": "none",\n           "trackListPositions": true\n       }\n   }\n}\n\'\n')),(0,r.kt)("p",null,"After defining the search view, we can retrieve the list of ",(0,r.kt)("em",{parentName:"p"},"Rhodes Hotel")," reviews:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(review.Property_Name == "Rhodes Hotel", "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("p",null,"When using the default Analyzer, you do not need to set the Analyzer context with the ANALYZER() function. The same results can be obtained by running the following query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\nSEARCH review.Property_Name == "Rhodes Hotel"\nRETURN review.Property_Name\n')),(0,r.kt)("h4",{id:"matching-with-negations"},"Matching with Negations"),(0,r.kt)("p",null,"You can search for items that do not have exact matching with specified criteria using the negations. In this scenario inequality can be checked with the ",(0,r.kt)("inlineCode",{parentName:"p"},"!=")," operator to return everything from the view index except the documents which do not satisfy the criterion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\nSEARCH ANALYZER(review.Property_Name != "Rhodes Hotel", "identity")\nRETURN review.Property_Name\n')),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Rhodes Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("h4",{id:"matching-multiple-strings"},"Matching Multiple Strings"),(0,r.kt)("p",null,"Exact value matching can be conducted considering several item values. You can use the logical ",(0,r.kt)("inlineCode",{parentName:"p"},"OR")," operator, ",(0,r.kt)("inlineCode",{parentName:"p"},"IN")," operator, or bind parameters."),(0,r.kt)("p",null,"The following examples query the same results:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(review.Property_Name == "Apex London Wall Hotel" OR review.Property_Name == "Corinthia Hotel London", "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(review.Property_Name IN ["Apex London Wall Hotel", "Corinthia Hotel London"], "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'{\n  "hotel_names": [\n    "Apex London Wall Hotel",\n    "Corinthia Hotel London"\n  ]\n}\n')),(0,r.kt)("p",null,"For the following example, you must specify the bind parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(review.Property_Name IN @hotel_names, "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("p",null,"These examples query a list of items (1,860 items in total) as shown below."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Apex London Wall Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Corinthia Hotel London")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Corinthia Hotel London")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Apex London Wall Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("h3",{id:"prefix-matching"},"Prefix Matching"),(0,r.kt)("p",null,"You can search for strings or tokens that start with one or more substrings with the ",(0,r.kt)("em",{parentName:"p"},"prefix")," feature of Macrometa GDN."),(0,r.kt)("p",null,"In the following example, we want to find all hotels starting with the word ",(0,r.kt)("inlineCode",{parentName:"p"},"The "),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(STARTS_WITH(review.Property_Name, "The "), "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("p",null,"This example queries a list of 3,963 records as shown below."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("p",null,"You can also include multiple prefixes. In the following example, we want to find all hotels starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"The ")," or `Hotel ``"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(STARTS_WITH(review.Property_Name, "The ") OR STARTS_WITH(review.Property_Name, "Hotel "), "identity")\n  RETURN review.Property_Name\n')),(0,r.kt)("p",null,"This example queries a list of 4,524 reviews that satisfy these criteria."),(0,r.kt)("p",null,"The following example shows how prefix matching is conducted on multiple attributes. In this scenario, we want to find all hotels starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"The ")," and the review titles that start with ",(0,r.kt)("inlineCode",{parentName:"p"},"Awesome "),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(STARTS_WITH(review.Property_Name, "The ") AND STARTS_WITH(review.Review_Title, "Awesome "), "identity")\n  RETURN {\n  Property_Name : review.Property_Name,\n  Review_Title : review.Review_Title\n  }\n')),(0,r.kt)("p",null,"This should result in the following three reviews:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Review_Title"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Dorchester"),(0,r.kt)("td",{parentName:"tr",align:null},"Awesome luxury hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Dorchester"),(0,r.kt)("td",{parentName:"tr",align:null},"Awesome Bathroom, great location, Superb service")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy"),(0,r.kt)("td",{parentName:"tr",align:null},"Awesome Again")))),(0,r.kt)("h3",{id:"range-queries"},"Range Queries"),(0,r.kt)("p",null,"Range queries allow for searching data that are above, below, or between a minimum and a maximum value. The main use case for range queries is to search numeric values in documents."),(0,r.kt)("p",null,"Range queries can be specified comparing to a number, comparing to a numeric range, as well as comparing between strings. "),(0,r.kt)("p",null,"When developing range queries in GDN we need not specify any Analyzers. This is because range queries deal with numeric values and those are not processed by Analyzers. We first need to remove the identity analyzer which we created in the ",(0,r.kt)("a",{parentName:"p",href:"#exact-value-matching"},"Exact Value Matching")," section. This can be achieved via the following cURL command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request PUT \'https://<HOST>/_fabric/Hotels/_api/search/view/sample1_view1/properties\' \\\n--header \'Content-Type: application/json\' \\\n--header \'Accept: application/json\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--data-raw \'{\n   "links": {\n       "hotel_reviews": {\n           "analyzers": [],\n           "fields": {\n            "Property_Name": {}\n           },\n           "includeAllFields": true,\n           "storeValues": "none",\n           "trackListPositions": true\n       }\n   }\n}\n\'\n')),(0,r.kt)("h4",{id:"comparing-to-a-number"},"Comparing to a Number"),(0,r.kt)("p",null,"Let's take the scenario where we want to select all the hotel reviews which have a rating of 5. This can be accomplished using the following query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH review.Review_Rating == 5\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"When executed the above query results in the following list of items (6764 in total)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Review_Rating"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Apex London Wall Hotel"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Corinthia Hotel London"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"..."),(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("p",null,"The range query can be executed considering a set of numeric items. For example, the following query finds all the reviews which had ratings 3, 4, or 5."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH review.Review_Rating IN [3, 4, 5]\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"Since the hotel review rating values specified in the data set are in the range 1...5, the same query can be specified using the > symbol as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH review.Review_Rating > 2\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"Each of the above queries should result in the same number of 9506 records."),(0,r.kt)("h4",{id:"comparing-to-a-numeric-range"},"Comparing to a Numeric Range"),(0,r.kt)("p",null,"Rather than specifying each and every item in a continuous numeric range the same can be specified using the ",(0,r.kt)("em",{parentName:"p"},"range operator"),". For example, the query in Listing 15 can be rewritten as follows,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH review.Review_Rating IN 3..5\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"IN","_","RANGE()")," function allows for specifying a more advanced version of the query shown in Listing 17 by allowing us to specify the boundary conditions. When executed this should result in 9506 records."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH IN_RANGE(review.Review_Rating, 3, 5, true, true)\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"Range search queries can be further augmented by using the standard comparison operators to search for values below and above a range. For example, one could specify a range query to collect all the reviews having ratings less than or equal to 2, greater than 4, and not equals to 1 as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view1\n  SEARCH (review.Review_Rating <= 2 OR review.Review_Rating > 4) AND review.Review_Rating != 1\n  SORT review.Review_Rating\n  RETURN {\n    Property_Name: review.Property_Name,\n    Review_Rating: review.Review_Rating\n    }\n")),(0,r.kt)("p",null,"When executed the above query should result in 7035 records."),(0,r.kt)("h4",{id:"comparing-strings"},"Comparing Strings"),(0,r.kt)("p",null,"The examples in the previous subsection were purely based on numeric values. However, range comparisons can be made on strings using the standard comparison operators as well as the ",(0,r.kt)("inlineCode",{parentName:"p"},"IN_RANGE()")," function. Before running such string comparison identity search Analyzer has to be defined by invoking the cURL command shown in Listing 2. For example, the following query selects all the hotel names which start with Apex until (exclusive of) hotel names which start with the letter D."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view1\n  SEARCH ANALYZER(IN_RANGE(review.Property_Name, "Apex", "D", true, false), "identity")\n  SORT review.Review_Rating\n  RETURN review.Property_Name\n')),(0,r.kt)("p",null,"The execution of the above query results in a list of items (2037 items in total) as follows. "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Apex London Wall Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Corinthia Hotel London")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"City View Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"City View Hotel")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("h2",{id:"full-text-token-search"},"Full-text Token Search"),(0,r.kt)("p",null,"When searching strings it is highly useful to search for tokens in full-text which can occur in any order. Text Analyzers tokenize the full-text strings so that each token can get indexed separately. There are two ways for searching for tokens called Token search and Phrase search. While the former is described in this section the latter is presented in Section 2.5."),(0,r.kt)("h3",{id:"token-search"},"Token Search"),(0,r.kt)("p",null,"This approach searches for token which can appear in any order. The words that are searched for has to be contained in the source string. First, a text analyzer view has to be defined via invoking a cURL command as follows,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'https://<HOST>/_fabric/Hotels/_api/search/view\' \\\n--header \'Content-Type: application/json\' \\\n--header \'Accept: application/json\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--data-raw \'{\n    "name": "sample1_view8",\n  "links": {\n    "hotel_reviews": {\n                    "analyzers": [],\n      "fields": {\n        "Review_Text": {\n          "analyzers": [\n            "text_en"\n          ]\n        }\n      }\n    }\n  },\n  "type": "search"\n}\n\'\n')),(0,r.kt)("p",null,"Once the view is ready we can specify a token search query which searches for the occurrence of at least one of the praising words ",(0,r.kt)("inlineCode",{parentName:"p"},"Awesome")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Excellent")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Lovely")," in a review text and select its review score as the result as shown in the following example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view8\n  SEARCH ANALYZER(review.Review_Text IN TOKENS("Awesome Excellent Lovely", "text_en"), "text_en")\n  RETURN review.Review_Rating\n')),(0,r.kt)("p",null,"This should query 3,803 review ratings:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Review_Rating"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("h2",{id:"phrase-and-proximity-search"},"Phrase and Proximity Search"),(0,r.kt)("p",null,"Phrase search allows for searching for phrases and nearby words in full text. One may also specify how many arbitrary tokens may occur between the defined tokens for word proximity searches. We can use the same search view defined in the previous section here as well."),(0,r.kt)("p",null,"Let's search for hotel review comments which say ",(0,r.kt)("inlineCode",{parentName:"p"},"rooms are small")," and select the hotel names and their review ratings."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view8\n  SEARCH ANALYZER(PHRASE(review.Review_Text, "rooms are small"), "text_en")\n  RETURN {\n  Property_Name: review.Property_Name,\n  Review_Rating: review.Review_Rating\n  }\n')),(0,r.kt)("p",null,"This should query 75 review comments:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Review_Rating"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The Savoy"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ridgemount Hotel"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Marble Arch Hotel"),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hotel Xenia, Autograph Collection"),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"..."),(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"PHRASE()")," function allows for specifying tokens and the number of wild card tokens in alternating order. This can be effectively utilized for two words with one arbitrary word in between the two words. For example, one could search for review comments specifying the number of nights the reviewer has stayed in the hotel as follows,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view8\n  SEARCH ANALYZER(PHRASE(review.Review_Text, "for", 1, "nights"), "text_en")\n  RETURN {\n  Property_Name: review.Property_Name,\n  Review_Rating: review.Review_Rating\n  }\n')),(0,r.kt)("p",null,"This example should query 859 results."),(0,r.kt)("h2",{id:"faceted-search"},"Faceted Search"),(0,r.kt)("p",null,"Faceted search allows for combining aggregation with search queries to retrieve how frequently values occur overall. We need to first define a view using the identity analyzer as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'https://<HOST>/_fabric/Hotels/_api/search/view\' \\\n--header \'Content-Type: application/json\' \\\n--header \'Accept: application/json\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--data-raw \'{\n    "name": "sample1_view9",\n  "links": {\n    "hotel_reviews": {\n                    "analyzers": [],\n      "fields": {\n        "Review_Text": {\n          "analyzers": [\n            "identity"\n          ]\n        }\n      }\n    }\n  },\n  "type": "search"\n}\n\'\n')),(0,r.kt)("p",null,"A number of reviews made for each and every hotel can be calculated using the faceted search query as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR review IN sample1_view8\n  COLLECT name = review.Property_Name WITH COUNT INTO count\n  RETURN { name, count}\n")),(0,r.kt)("p",null,"This should indicate the dataset has reviews on 20 hotels. The first few results are listed below,"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property_Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Review_Rating"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"45 Park Lane - Dorchester Collection"),(0,r.kt)("td",{parentName:"tr",align:null},"80")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ridgemount HotelA To Z Hotel"),(0,r.kt)("td",{parentName:"tr",align:null},"82")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Apex London Wall Hotel"),(0,r.kt)("td",{parentName:"tr",align:null},"806")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bulgari Hotel, London"),(0,r.kt)("td",{parentName:"tr",align:null},"169")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"..."),(0,r.kt)("td",{parentName:"tr",align:null},"...")))),(0,r.kt)("p",null,'To look up how many times a review carries the title "Very good" the following query can be utilized. Note that the case of the term "Very good" is exactly matched. Hence although the title very good appears five times across this hotel review data set, only three reviews are listed as the result for the below query.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view10\n      SEARCH ANALYZER(review.Review_Title == "Very good", "identity")\nCOLLECT WITH COUNT INTO count\n  RETURN count\n')),(0,r.kt)("p",null,"The above query should result in 3 records. For a query like above which is having a simple single condition, there is an optimization that could accurately determine the count from index data faster than the standard COLLECT as follows,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'FOR review IN sample1_view10\n      SEARCH ANALYZER(review.Review_Title == "Very good", "identity")\n      OPTIONS { countApproximate: "cost" }\nCOLLECT WITH COUNT INTO count\n  RETURN count\n')),(0,r.kt)("p",null,'If we need all the five occurrences of the title "very good" we can write a query as follows,'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'Let alternatives = ["Very good", "Very Good", "very good"]\nFOR alternative in alternatives\nLET count = FIRST(\nFOR review IN sample1_view10\n      SEARCH ANALYZER(review.Review_Title == alternative, "identity")\n      OPTIONS { countApproximate: "cost" }\nCOLLECT WITH COUNT INTO count\n  RETURN count\n  ) RETURN {alternative, count}\n')),(0,r.kt)("p",null,"Execution of the above query should result in three records as follows,"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"alternative"),(0,r.kt)("th",{parentName:"tr",align:null},"count"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Very good"),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Very Good"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"very good"),(0,r.kt)("td",{parentName:"tr",align:null},"1")))),(0,r.kt)("h2",{id:"geospatial-search"},"Geospatial Search"),(0,r.kt)("p",null,"Geospatial search is a less frequently found but very useful feature when it comes to implementing geography-related information processing in general data analytics applications. Traditionally a special class of information systems called Geographic Information Systems (GIS) have been used to deal with spatial data extensively. However, NoSQL data store such as Macrometa GDN has the capability of storing and searching on spatial data which has become very useful when developing applications where geospatial search has become one of the requirements of the complete application."),(0,r.kt)("p",null,"Macrometa GDN supports geospatial queries such as finding coordinates and shapes within a radius or an area. "),(0,r.kt)("h3",{id:"geospatial-datasets"},"Geospatial Datasets"),(0,r.kt)("p",null,"In order to tryout geospatial search capabilities of Macrometa GDN we have selected two datasets from Seattle metropolis of the USA. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Macrometacorp/datasets/blob/master/geospatial-search/city.json"},"first")," is a map of council districts of the Seattle city. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Macrometacorp/datasets/blob/master/geospatial-search/schools.json"},"second")," dataset corresponds to public schools of Seattle. These two refined datasets were obtained from the ",(0,r.kt)("a",{parentName:"p",href:"http://DATA.GOV"},"DATA.GOV")," website."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'https://<HOST>/_fabric/SeattleSchools/_api/import/schools\' \\\n--header \'Authorization: <BEARER_TOKEN>\' \\\n--header \'Accept: application/json\' \\\n--header \'Content-Type: text/plain\' \\\n--data-raw \'{\n  "data": [\n{ "type": "Feature", "properties": { "OBJECTID": 1, "TYPE": "NonStandard", "SCHOOL": "QUEEN ANNE GYM", "ADDRESS": "1431 2nd Ave N", "SE_ANNO_CAD_DATA": "null", "NAME": "Queen Anne Gym", "GRADE": "9-12", "CITY": "Seattle", "ZIP": "98109", "PHONE": "null", "WEBSITE": "null", "XCOORD": 1265680.67393531, "YCOORD": 234243.29115321999, "SITE_USE": "Active", "PRJ_ENRLLMNT": "null" }, "geometry": { "type": "Point", "coordinates": [ -122.353265218350501, 47.632022747314181 ] } }\n],\n  "details": false,\n  "primaryKey": "",\n  "replace": false\n}\'\n')),(0,r.kt)("p",null,'The following example shows insertion of only one data item using the cURL command for the illustration purposes. However, one needs to replace [] of "data" element with the content from the schools file before running the following sample queries. Furthermore, ',(0,r.kt)("inlineCode",{parentName:"p"},"HOST")," and BEARER_TOKEN` values have to be replaced similar to the previous examples."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl --location --request POST 'https://<HOST>/_fabric/SeattleSchools/_api/import/city' \\\n--header 'Authorization: <BEARER_TOKEN>' \\\n--header 'Accept: application/json' \\\n--header 'Content-Type: text/plain' \\\n--data-raw '{\n  \"data\": <DATA>,\n  \"details\": false,\n  \"primaryKey\": \"\",\n  \"replace\": false\n}'\n")),(0,r.kt)("p",null,"Before running the next cURL example, we need to replace the label ",(0,r.kt)("inlineCode",{parentName:"p"},"DATA")," with the complete content from Seattle's council districts data file."),(0,r.kt)("p",null,"First, we will execute a query to identify all the schools which are located within 1,000 meters of Saint George Church. This can be specified as follows, "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LET loc = GEO_POINT(-122.31551191249362, 47.55458207164884)\nFOR x IN schools\n  FILTER GEO_DISTANCE(loc, x.geometry) <= 1000\n  RETURN x.properties.NAME\n")),(0,r.kt)("p",null,"This should result in two schools named Cleveland STEM and Maple. These two schools along with the Saint George Church can be visualized on a map as shown in Figure 3."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Visualization of geospatial query results",src:a(19650).Z,width:"613",height:"364"})))}m.isMDXComponent=!0},19650:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/map-2dffbf93f5bc5985ee74b068f5d90581.png"},67383:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/schema-90b368ce78535a94d0096eda3298ced7.jpg"}}]);