"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[41829],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},24034:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const i={sidebar_position:50,title:"Geo-Spatial Indexes"},r=void 0,l={unversionedId:"collections/indexing/geo-indexes",id:"collections/indexing/geo-indexes",title:"Geo-Spatial Indexes",description:'GDN features Google S2{:target="_blank"} based geospatial index. Indexing is supported for a subset of the GeoJSON geometry types as well as simple latitude longitude pairs.',source:"@site/docs/collections/indexing/geo-indexes.md",sourceDirName:"collections/indexing",slug:"/collections/indexing/geo-indexes",permalink:"/docs/collections/indexing/geo-indexes",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/collections/indexing/geo-indexes.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{sidebar_position:50,title:"Geo-Spatial Indexes"},sidebar:"defaultSidebar",previous:{title:"Fulltext Indexes",permalink:"/docs/collections/indexing/fulltext-indexes"},next:{title:"Persistent Indexes",permalink:"/docs/collections/indexing/persistent-indexes"}},s={},p=[{value:"Create Geo Index in GDN Console",id:"create-geo-index-in-gdn-console",level:2},{value:"GeoJSON Mode",id:"geojson-mode",level:2},{value:"Non-GeoJSON mode",id:"non-geojson-mode",level:2},{value:"Indexed GeoSpatial Queries",id:"indexed-geospatial-queries",level:2},{value:"Query for Results near Origin (NEAR type query)",id:"query-for-results-near-origin-near-type-query",level:2},{value:"Query for Sorted Results near Origin (NEAR type query)",id:"query-for-sorted-results-near-origin-near-type-query",level:2},{value:"Query for Results within Distance",id:"query-for-results-within-distance",level:2},{value:"Query for Results contained in Polygon",id:"query-for-results-contained-in-polygon",level:2},{value:"Query for Results Intersecting a Polygon",id:"query-for-results-intersecting-a-polygon",level:2},{value:"GeoJSON",id:"geojson",level:2},{value:"Point",id:"point",level:2},{value:"MultiPoint",id:"multipoint",level:2},{value:"LineString",id:"linestring",level:2},{value:"MultiLineString",id:"multilinestring",level:2},{value:"Polygon",id:"polygon",level:2},{value:"MultiPolygon",id:"multipolygon",level:2},{value:"Examples",id:"examples",level:2}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"GDN features ",(0,o.kt)("a",{parentName:"p",href:"http://s2geometry.io/"},"Google S2"),'{:target="_blank"} based geospatial index. Indexing is supported for a subset of the ',(0,o.kt)("a",{parentName:"p",href:"#geojson"},(0,o.kt)("strong",{parentName:"a"},"GeoJSON"))," geometry types as well as simple latitude longitude pairs."),(0,o.kt)("p",null,"C8QL's geospatial functions and GeoJSON constructors are described in ",(0,o.kt)("a",{parentName:"p",href:"/docs/collections/indexing/working-with-indexes"},"Geo functions"),"."),(0,o.kt)("p",null,"The geospatial index supports containment and intersection queries for various geometric 2D shapes. You should be mainly using AQL queries to perform these types of operations. The index can operate in ",(0,o.kt)("strong",{parentName:"p"},"two different modes"),", depending on if you want to use the GeoJSON data-format or not. The modes are mainly toggled by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"geoJson")," field when creating the index."),(0,o.kt)("p",null,"This index assumes coordinates with the latitude between -90 and 90 degrees and the longitude between -180 and 180 degrees. A geo index will ignore all documents which do not fulfill these requirements."),(0,o.kt)("h2",{id:"create-geo-index-in-gdn-console"},"Create Geo Index in GDN Console"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://auth-play.macrometa.io/"},"Log in to your Macrometa account"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Click ",(0,o.kt)("strong",{parentName:"p"},"Data > Collections"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Click the collection that you want to create an index for.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Click ",(0,o.kt)("strong",{parentName:"p"},"Indexes"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In ",(0,o.kt)("strong",{parentName:"p"},"Type"),", select ",(0,o.kt)("strong",{parentName:"p"},"Geo Index"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Enter the following information:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Fields -")," Choose between one or two attribute paths, latitude and/or longitude, from the collection."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Name -")," The name of the index. If left blank, then Macrometa autogenerates the name."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Geo JSON -")," Set to true if attributes are stored in arrays []. Otherwise, set it to false. For more information, refer to ",(0,o.kt)("a",{parentName:"li",href:"#geojson-mode"},"GeoJSON Mode")," and ",(0,o.kt)("a",{parentName:"li",href:"#non-geojson-mode"},"Non-GeoJSON Mode"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Create in Background -")," If true, will create an index in the background rather than lock the collection while the index is created. This allows for basic CRUD operations to occur while the index is created. For more information, refer to ",(0,o.kt)("a",{parentName:"li",href:"/docs/collections/indexing/create-index-in-background"},"Create Index in Background"),"."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Click ",(0,o.kt)("strong",{parentName:"p"},"Create"),"."))),(0,o.kt)("h2",{id:"geojson-mode"},"GeoJSON Mode"),(0,o.kt)("p",null,"To create an index in GeoJSON mode execute:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\'  \\\n -H \'Authorization: bearer <token>\'                                                                        \\\n -d \'{ "fields": [ "type" : "geo", ."fields": ["geometry"],  "geoJson": true }\'\n')),(0,o.kt)("p",null,"This creates the index on all documents and uses ",(0,o.kt)("em",{parentName:"p"},"geometry")," as the attributed field where the value is either a ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1"},"Geometry Object"),'{:target="',(0,o.kt)("em",{parentName:"p"},'blank"} ',(0,o.kt)("strong",{parentName:"em"},"or")," a_coordinate array"),"."),(0,o.kt)("p",null,"The array must contain at least two numeric values with longitude (first value) and the latitude (second value). This corresponds to the format described in ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.1"},"RFC 7946 Position"),'{:target="_blank"}.'),(0,o.kt)("p",null,"All documents, which do not have the attribute path or have a non-conform value in it, are excluded from the index."),(0,o.kt)("p",null,"A geo index is implicitly sparse, and there is no way to control its sparsity. In case that the index was successfully created, an object with the index details, including the index-identifier, is returned."),(0,o.kt)("h2",{id:"non-geojson-mode"},"Non-GeoJSON mode"),(0,o.kt)("p",null,"This index mode exclusively supports indexing on coordinate arrays. Values that contain GeoJSON or other types of data will be ignored. In the non-GeoJSON mode the index can be created on one or two fields."),(0,o.kt)("p",null,"To create a geo-spatial index on all documents using ",(0,o.kt)("em",{parentName:"p"},"latitude")," and ",(0,o.kt)("em",{parentName:"p"},"longitude")," as separate attribute paths, two paths need to be specified in the ",(0,o.kt)("em",{parentName:"p"},"fields")," array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\' \\\n -H \'Authorization: bearer <token>\'                                                                       \\  \n -d \'{ "fields": [ "type" : "geo", ."fields": ["latitude", "longitude"] }\'\n')),(0,o.kt)("p",null,"The first field is always defined to be the ",(0,o.kt)("em",{parentName:"p"},"latitude")," and the second is the ",(0,o.kt)("em",{parentName:"p"},"longitude"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"geoJson")," flag is implicitly ",(0,o.kt)("em",{parentName:"p"},"false")," in this mode."),(0,o.kt)("p",null,"Alternatively you can specify only one field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\' \\\n -H \'Authorization: bearer <token>\'                                                                       \\\n -d \'{ "fields": [ "type" : "geo", ."fields": ["location"],  "geoJson": false }\'\n')),(0,o.kt)("p",null,"It creates a geospatial index on all documents using ",(0,o.kt)("em",{parentName:"p"},"location")," as the path to the coordinates. The value of the attribute has to be an array with at least two numeric values. The array must contain the latitude (first value) and the longitude (second value)."),(0,o.kt)("p",null,"All documents, which do not have the attribute path(s) or have a non-conforming value in it, are excluded from the index."),(0,o.kt)("p",null,"A geo index is implicitly sparse, and there is no way to control its sparsity. In case that the index was successfully created, an object with the index details, including the index-identifier, is returned."),(0,o.kt)("p",null,"In case that the index was successfully created, an object with the index details, including the index-identifier, is returned."),(0,o.kt)("h2",{id:"indexed-geospatial-queries"},"Indexed GeoSpatial Queries"),(0,o.kt)("p",null,"The geospatial index supports a variety of C8QL queries, which can be built with the help of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/collections/indexing/working-with-indexes"},"geo utility functions"),". There are three specific geo functions that can be optimized, provided that they are used correctly: ",(0,o.kt)("inlineCode",{parentName:"p"},"GEO_DISTANCE, GEO_CONTAINS, GEO_INTERSECTS"),". Additionally, there is a built-in support to optimize the older geo functions ",(0,o.kt)("inlineCode",{parentName:"p"},"DISTANCE"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"NEAR")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"WITHIN")," (the last two only if they are used in their 4 argument version, without ",(0,o.kt)("em",{parentName:"p"},"distanceName"),")."),(0,o.kt)("p",null,"When in doubt whether your query is being properly optimized, check the ",(0,o.kt)("a",{parentName:"p",href:"/docs/collections/indexing/working-with-indexes"},"C8QL explain")," output to check for index usage."),(0,o.kt)("h2",{id:"query-for-results-near-origin-near-type-query"},"Query for Results near Origin (NEAR type query)"),(0,o.kt)("p",null,"A basic example of a query for results near an origin point:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"FOR x IN geo_collection\n  FILTER GEO_DISTANCE([@lng, @lat], x.geometry) <= 100000\n  RETURN x._key\n")),(0,o.kt)("p",null,"The first parameter can be a GeoJSON object or a coordinate array in ",(0,o.kt)("inlineCode",{parentName:"p"},"[longitude, latitude]")," ordering. The second parameter is the document field on which the index was created. The function ",(0,o.kt)("inlineCode",{parentName:"p"},"GEO_DISTANCE")," always returns the distance in meters, so will receive results up until ",(0,o.kt)("em",{parentName:"p"},"100km"),"."),(0,o.kt)("h2",{id:"query-for-sorted-results-near-origin-near-type-query"},"Query for Sorted Results near Origin (NEAR type query)"),(0,o.kt)("p",null,"A basic example of a query for the 1000 nearest results to an origin point (ascending sorting):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"FOR x IN geo_collection\n  SORT GEO_DISTANCE([@lng, @lat], x.geometry) ASC\n  LIMIT 1000\n  RETURN x._key\n")),(0,o.kt)("p",null,"The first parameter can be a GeoJSON object or a coordinate array in ",(0,o.kt)("inlineCode",{parentName:"p"},"[longitude, latitude]")," ordering. The second parameter is the documents field on which the index was created."),(0,o.kt)("p",null,"You may also get results farthest away (distance sorted in descending order):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"FOR x IN geo_collection\n  SORT GEO_DISTANCE([@lng, @lat], x.geometry) DESC\n  LIMIT 1000\n  RETURN x._key\n")),(0,o.kt)("h2",{id:"query-for-results-within-distance"},"Query for Results within Distance"),(0,o.kt)("p",null,"A query which returns documents at a distance of ",(0,o.kt)("em",{parentName:"p"},"1km")," or farther away, up to ",(0,o.kt)("em",{parentName:"p"},"100km")," from the origin. This will return the documents with a GeoJSON value that is located in the specified search annulus."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"FOR x IN geo_collection\n  FILTER GEO_DISTANCE([@lng, @lat], x.geometry) <= 100000\n  FILTER GEO_DISTANCE([@lng, @lat], x.geometry) >= 1000\n  RETURN x\n")),(0,o.kt)("h2",{id:"query-for-results-contained-in-polygon"},"Query for Results contained in Polygon"),(0,o.kt)("p",null,"A query which returns documents whose stored geometry is contained within a GeoJSON Polygon."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"LET polygon = GEO_POLYGON([[[60,35],[50,5],[75,10],[70,35]]])\nFOR x IN geo_collection\n  FILTER GEO_CONTAINS(polygon, x.geometry)\n  RETURN x\n")),(0,o.kt)("p",null,"The first parameter of ",(0,o.kt)("inlineCode",{parentName:"p"},"GEO_CONTAINS")," must be a polygon. Other types are not valid. The second parameter must contain the document field on which the index was created."),(0,o.kt)("h2",{id:"query-for-results-intersecting-a-polygon"},"Query for Results Intersecting a Polygon"),(0,o.kt)("p",null,"A query which returns documents with an intersection of their stored geometry and a GeoJSON Polygon."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"LET polygon = GEO_POLYGON([[[60,35],[50,5],[75,10],[70,35]]])\nFOR x IN geo_collection\n  FILTER GEO_INTERSECTS(polygon, x.geometry)\n  RETURN x\n")),(0,o.kt)("p",null,"The first parameter of ",(0,o.kt)("inlineCode",{parentName:"p"},"GEO_INTERSECTS")," must be a polygon. Other types are not valid. The second parameter must contain the document field on which the index was created."),(0,o.kt)("h2",{id:"geojson"},"GeoJSON"),(0,o.kt)("p",null,"GeoJSON is a geospatial data format based on JSON. It defines several different types of JSON objects and the way in which they can be combined to represent data about geographic shapes on the earth surface. GeoJSON uses a geographic coordinate reference system, World Geodetic System 1984 (WGS 84), and units of decimal degrees."),(0,o.kt)("p",null,"Internally GDN maps all coordinates onto a unit sphere. Distances are projected onto a sphere with the Earth's ",(0,o.kt)("em",{parentName:"p"},"Volumetric mean radius")," of ",(0,o.kt)("em",{parentName:"p"},"6371 km"),". GDN implements a useful subset of the GeoJSON format ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946"},"(RFC 7946)"),'{:target="_blank"}. Feature Objects and the GeometryCollection type are not supported.'),(0,o.kt)("p",null,"Supported geometry object types are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Point"),(0,o.kt)("li",{parentName:"ul"},"MultiPoint"),(0,o.kt)("li",{parentName:"ul"},"LineString"),(0,o.kt)("li",{parentName:"ul"},"MultiLineString"),(0,o.kt)("li",{parentName:"ul"},"Polygon")),(0,o.kt)("h2",{id:"point"},"Point"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.2"},"GeoJSON Point"),'{:target="_blank"} is a ',(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.1"},"position"),'{:target="_blank"} comprised of a longitude and a latitude:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "Point",\n  "coordinates": [100.0, 0.0]\n}\n')),(0,o.kt)("h2",{id:"multipoint"},"MultiPoint"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.7"},"GeoJSON MultiPoint"),'{:target="_blank"} is an array of positions:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "MultiPoint",\n  "coordinates": [\n    [100.0, 0.0],\n    [101.0, 1.0]\n  ]\n}\n')),(0,o.kt)("h2",{id:"linestring"},"LineString"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.4"},"GeoJSON LineString"),'{:target="_blank"} is an array of two or more positions:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "LineString",\n  "coordinates": [\n    [100.0, 0.0],\n    [101.0, 1.0]\n  ]\n}\n')),(0,o.kt)("h2",{id:"multilinestring"},"MultiLineString"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.5"},"GeoJSON MultiLineString"),'{:target="_blank"} is an array of LineString coordinate arrays:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "MultiLineString",\n  "coordinates": [\n    [\n      [100.0, 0.0],\n      [101.0, 1.0]\n    ],\n    [\n      [102.0, 2.0],\n      [103.0, 3.0]\n    ]\n  ]\n}\n')),(0,o.kt)("h2",{id:"polygon"},"Polygon"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.6"},"GeoJSON Polygon"),'{:target="',(0,o.kt)("em",{parentName:"p"},'blank"} consists of a series of closed ',(0,o.kt)("inlineCode",{parentName:"em"},"LineString")," objects (ring-like). These _Linear Ring")," objects consist of four or more vertices with the first and last coordinate pairs being equal. Coordinates of a Polygon are an array of linear ring coordinate arrays. The first element in the array represents the exterior ring."),(0,o.kt)("p",null,"Any subsequent elements represent interior rings (holes within the surface)."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A linear ring may not be empty, it needs at least three ",(0,o.kt)("em",{parentName:"li"},"distinct")," coordinates"),(0,o.kt)("li",{parentName:"ul"},"Within the same linear ring consecutive coordinates may be the same, otherwise (except the first and last one) all coordinates need to be distinct"),(0,o.kt)("li",{parentName:"ul"},"A linear ring defines two regions on the sphere. GDN will always interpret the region of smaller area to be the interior of the ring. This introduces a practical limitation that no polygon may have an outer ring enclosing more than half the Earth's surface")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"No Holes:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "Polygon",\n    "coordinates": [\n    [\n      [100.0, 0.0],\n      [101.0, 0.0],\n      [101.0, 1.0],\n      [100.0, 1.0],\n      [100.0, 0.0]\n    ]\n  ]\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"With Holes:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The exterior ring should not self-intersect."),(0,o.kt)("li",{parentName:"ul"},"The interior rings must be contained in the outer ring"),(0,o.kt)("li",{parentName:"ul"},"No two rings can cross each other, i.e. no ring may intersect both the interior and exterior face of another ring"),(0,o.kt)("li",{parentName:"ul"},"Rings cannot share edges, they may however share vertices"),(0,o.kt)("li",{parentName:"ul"},"No ring may be empty"),(0,o.kt)("li",{parentName:"ul"},"Polygon rings should follow the right-hand rule for orientation (counterclockwise external rings, clockwise internal rings).")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "Polygon",\n  "coordinates": [\n    [\n      [100.0, 0.0],\n      [101.0, 0.0],\n      [101.0, 1.0],\n      [100.0, 1.0],\n      [100.0, 0.0]\n    ],\n    [\n      [100.8, 0.8],\n      [100.8, 0.2],\n      [100.2, 0.2],\n      [100.2, 0.8],\n      [100.8, 0.8]\n    ]\n  ]\n}\n')),(0,o.kt)("h2",{id:"multipolygon"},"MultiPolygon"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.6"},"GeoJSON MultiPolygon"),'{:target="',(0,o.kt)("em",{parentName:"p"},'blank"} consists of multiple polygons. The "coordinates" member is an array of_Polygon')," coordinate arrays."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Polygons in the same MultiPolygon may not share edges, they may share coordinates"),(0,o.kt)("li",{parentName:"ul"},"Polygons and rings must not be empty"),(0,o.kt)("li",{parentName:"ul"},"A linear ring defines two regions on the sphere. GDN will always interpret the region of smaller area to be the interior of the ring. This introduces a practical limitation that no polygon may have an outer ring enclosing more than half the Earth's surface"),(0,o.kt)("li",{parentName:"ul"},"Linear rings ",(0,o.kt)("strong",{parentName:"li"},"must")," follow the right-hand rule for orientation (counterclockwise external rings, clockwise internal rings).")),(0,o.kt)("p",null,"Example with two polygons, the second one with a hole:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "type": "MultiPolygon",\n    "coordinates": [\n        [\n            [\n                [102.0, 2.0],\n                [103.0, 2.0],\n                [103.0, 3.0],\n                [102.0, 3.0],\n                [102.0, 2.0]\n            ]\n        ],\n        [\n            [\n                [100.0, 0.0],\n                [101.0, 0.0],\n                [101.0, 1.0],\n                [100.0, 1.0],\n                [100.0, 0.0]\n            ],\n            [\n                [100.2, 0.2],\n                [100.2, 0.8],\n                [100.8, 0.8],\n                [100.8, 0.2],\n                [100.2, 0.2]\n            ]\n        ]\n    ]\n}\n')),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"ensures that a geo index exists"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\' \\\n -H \'Authorization: bearer <token>\'                                                                       \\\n -d \'{ "fields": [ "type" : "geo", ."fields": ["location"]}\'\n')),(0,o.kt)("p",null,"Creates a geospatial index on all documents using ",(0,o.kt)("em",{parentName:"p"},"location")," as the path to the coordinates. The value of the attribute has to be an array with at least two numeric values. The array must contain the latitude (first value) and the longitude (second value)."),(0,o.kt)("p",null,"All documents, which do not have the attribute path or have a non-conforming value in it, are excluded from the index."),(0,o.kt)("p",null,"A geo index is implicitly sparse, and there is no way to control its sparsity."),(0,o.kt)("p",null,"In case that the index was successfully created, an object with the index details, including the index-identifier, is returned."),(0,o.kt)("p",null,"To create a geo index on an array attribute that contains longitude first, set the ",(0,o.kt)("em",{parentName:"p"},"geoJson")," attribute to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". This corresponds to the format described in ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7946#section-3.1.1"},"RFC 7946 Position"),'{:target="_blank"}'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\' \\\n -H \'Authorization: bearer <token>\'                                                                       \\\n -d \'{ "fields": [ "type" : "geo", ."fields": ["location"],  "geoJson": true }\'\n')),(0,o.kt)("p",null,"To create a geo-spatial index on all documents using ",(0,o.kt)("em",{parentName:"p"},"latitude")," and ",(0,o.kt)("em",{parentName:"p"},"longitude")," as separate attribute paths, two paths need to be specified in the ",(0,o.kt)("em",{parentName:"p"},"fields")," array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\'  \\\n -H \'Authorization: bearer <token>\'                                                                        \\\n -d \'{ "fields": [ "type" : "geo", ."fields": ["latitude", "longitude" ] }\'\n')),(0,o.kt)("p",null,"In case that the index was successfully created, an object with the index details, including the index-identifier, is returned."),(0,o.kt)("p",null,"ensures that a geo index exists"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cURL"},'curl -X \'POST\' \'https://api-play.paas.macrometa.io/_fabric/_system/_api/index/geo?collection=collectionName\' \\\n -H \'Authorization: bearer <token>\'                                                                       \\\n -d \'{ "fields": [ "type" : "geo", ."fields": [ "location" ] }\'\n')),(0,o.kt)("p",null,"This method is an alias for ",(0,o.kt)("em",{parentName:"p"},"ensureGeoIndex")," since geo indexes are always sparse, meaning that documents that do not contain the index attributes or has non-numeric values in the index attributes will not be indexed. ",(0,o.kt)("em",{parentName:"p"},"ensureGeoConstraint")," is deprecated and ",(0,o.kt)("em",{parentName:"p"},"ensureGeoIndex")," should be used instead."),(0,o.kt)("p",null,"The index does not provide a ",(0,o.kt)("inlineCode",{parentName:"p"},"unique")," option because of its limited usability. It would prevent identical coordinates from being inserted only, but even a slightly different location (like 1 inch or 1 cm off) would be unique again and not considered a duplicate, although it probably should. The desired threshold for detecting duplicates may vary for every project (including how to calculate the distance even) and needs to be implemented on the application layer as needed."))}c.isMDXComponent=!0}}]);