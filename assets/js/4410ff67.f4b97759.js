"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[56295],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},13210:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:2,title:"Shortest Path"},l=void 0,i={unversionedId:"queryworkers/c8ql/graphs/shortest-path",id:"queryworkers/c8ql/graphs/shortest-path",title:"Shortest Path",description:"General idea",source:"@site/docs/queryworkers/c8ql/graphs/shortest-path.md",sourceDirName:"queryworkers/c8ql/graphs",slug:"/queryworkers/c8ql/graphs/shortest-path",permalink:"/docs/queryworkers/c8ql/graphs/shortest-path",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/graphs/shortest-path.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Shortest Path"},sidebar:"defaultSidebar",previous:{title:"Graphs",permalink:"/docs/queryworkers/c8ql/graphs/"},next:{title:"k Shortest Paths",permalink:"/docs/queryworkers/c8ql/graphs/k-shortest-paths"}},s={},p=[{value:"General idea",id:"general-idea",level:2},{value:"Example execution",id:"example-execution",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Working with named graphs",id:"working-with-named-graphs",level:3},{value:"Working with collection sets",id:"working-with-collection-sets",level:3},{value:"Traversing in mixed directions",id:"traversing-in-mixed-directions",level:3},{value:"Conditional shortest path",id:"conditional-shortest-path",level:2},{value:"Examples",id:"examples",level:2}],c={toc:p};function h(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"general-idea"},"General idea"),(0,r.kt)("p",null,"This type of query is supposed to find the shortest path between two given documents (",(0,r.kt)("inlineCode",{parentName:"p"},"startVertex")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"targetVertex"),") in your graph. For all vertices on this shortest path you will get a result in form of a set with two items:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The vertex on this path."),(0,r.kt)("li",{parentName:"ol"},"The edge pointing to it.")),(0,r.kt)("h3",{id:"example-execution"},"Example execution"),(0,r.kt)("p",null,"Let's take a look at a simple example to explain how it works. This is the graph that we are going to find a shortest path on:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"traversal graph",src:n(91782).Z,width:"2074",height:"1588"})),(0,r.kt)("p",null,"Now we use the following parameters for our query:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We start at the vertex ",(0,r.kt)("strong",{parentName:"li"},"A"),"."),(0,r.kt)("li",{parentName:"ol"},"We finish with the vertex ",(0,r.kt)("strong",{parentName:"li"},"D"),".")),(0,r.kt)("p",null,"So obviously we will have the vertices ",(0,r.kt)("strong",{parentName:"p"},"A"),", ",(0,r.kt)("strong",{parentName:"p"},"B"),", ",(0,r.kt)("strong",{parentName:"p"},"C")," and ",(0,r.kt)("strong",{parentName:"p"},"D")," on the shortest path in exactly this order. Than the shortest path statement will return the following pairs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Vertex"),(0,r.kt)("th",{parentName:"tr",align:null},"Edge"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"null")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"A \u2192 B")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"B \u2192 C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"D"),(0,r.kt)("td",{parentName:"tr",align:null},"C \u2192 D")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The first edge will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," because there is no edge pointing to the ",(0,r.kt)("inlineCode",{parentName:"p"},"startVertex"),".")),(0,r.kt)("h2",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"Now let's see how we can write a shortest path query. You have two options here, you can either use a named graph or a set of edge collections (anonymous graph)."),(0,r.kt)("h3",{id:"working-with-named-graphs"},"Working with named graphs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR vertex[, edge]\n  IN OUTBOUND|INBOUND|ANY SHORTEST_PATH\n  startVertex TO targetVertex\n  GRAPH graphName\n  [OPTIONS options]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"FOR"),": emits up to two variables:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"vertex")," (object): the current vertex on the shortest path"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"edge")," (object, ",(0,r.kt)("em",{parentName:"li"},"optional"),"): the edge pointing to the vertex"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"IN")," ",(0,r.kt)("inlineCode",{parentName:"p"},"OUTBOUND|INBOUND|ANY"),": defines in which direction edges are followed\n(outgoing, incoming, or both)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startVertex")," TO ",(0,r.kt)("inlineCode",{parentName:"li"},"targetVertex")," (both string","|","object): the two vertices between which the shortest path will be computed. This can be specified in the form of an ID string or in the form of a document with the attribute ",(0,r.kt)("inlineCode",{parentName:"li"},"_id"),". All other values will lead to a warning and an empty result. If one of the specified documents does not exist, the result is empty as well and there is no warning."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"GRAPH")," ",(0,r.kt)("strong",{parentName:"p"},"graphName")," (string): the name identifying the named graph. Its vertex and\nedge collections will be looked up.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"OPTIONS")," ",(0,r.kt)("strong",{parentName:"p"},"options")," (object, ",(0,r.kt)("em",{parentName:"p"},"optional"),"): used to modify the execution of the\ntraversal. Only the following attributes have an effect, all others are ignored:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"weightAttribute")," (string): a top-level edge attribute that should be used to read the edge weight. If the attribute is not existent or not numeric, the ",(0,r.kt)("em",{parentName:"li"},"defaultWeight")," will be used instead."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"defaultWeight")," (number): this value will be used as fallback if there is no ",(0,r.kt)("em",{parentName:"li"},"weightAttribute")," in the edge document, or if it's not a number. The default is 1.")))),(0,r.kt)("h3",{id:"working-with-collection-sets"},"Working with collection sets"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR vertex[, edge]\n  IN OUTBOUND|INBOUND|ANY SHORTEST_PATH\n  startVertex TO targetVertex\n  edgeCollection1, ..., edgeCollectionN\n  [OPTIONS options]\n")),(0,r.kt)("p",null,"Instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"GRAPH graphName")," you may specify a list of edge collections (anonymous graph). The involved vertex collections are determined by the edges of the given edge collections. The rest of the behavior is similar to the named version."),(0,r.kt)("h3",{id:"traversing-in-mixed-directions"},"Traversing in mixed directions"),(0,r.kt)("p",null,"For shortest path with a list of edge collections you can optionally specify the direction for some of the edge collections. Say for example you have three edge collections ",(0,r.kt)("em",{parentName:"p"},"edges1"),", ",(0,r.kt)("em",{parentName:"p"},"edges2")," and ",(0,r.kt)("em",{parentName:"p"},"edges3"),", where in ",(0,r.kt)("em",{parentName:"p"},"edges2")," the direction has no relevance, but in ",(0,r.kt)("em",{parentName:"p"},"edges1")," and ",(0,r.kt)("em",{parentName:"p"},"edges3")," the direction should be taken into account. In this case you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"OUTBOUND")," as general search direction and ",(0,r.kt)("inlineCode",{parentName:"p"},"ANY")," specifically for ",(0,r.kt)("em",{parentName:"p"},"edges2")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR vertex IN OUTBOUND SHORTEST_PATH\n  startVertex TO targetVertex\n  edges1, ANY edges2, edges3\n")),(0,r.kt)("p",null,"All collections in the list that do not specify their own direction will use the direction defined after ",(0,r.kt)("inlineCode",{parentName:"p"},"IN")," (here: ",(0,r.kt)("inlineCode",{parentName:"p"},"OUTBOUND"),"). This allows to use a different direction for each collection in your path search."),(0,r.kt)("h2",{id:"conditional-shortest-path"},"Conditional shortest path"),(0,r.kt)("p",null,'The SHORTEST_PATH computation will only find an unconditioned shortest path. With this construct it is not possible to define a condition like: "Find the shortest path where all edges are of type ',(0,r.kt)("em",{parentName:"p"},"X"),'". If you want to do this, use a normal ',(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/graphs/traversals"},"Traversal")," instead with the option ",(0,r.kt)("inlineCode",{parentName:"p"},"{bfs: true}")," in combination with ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT 1"),"."),(0,r.kt)("p",null,"Please also consider ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/operations/with"},"to use ",(0,r.kt)("inlineCode",{parentName:"a"},"WITH"))," to specify the collections you expect to be involved."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"We will create a simple symmetric traversal demonstration graph:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"traversal graph",src:n(91782).Z,width:"2074",height:"1588"})),(0,r.kt)("p",null,"We start with the shortest path from ",(0,r.kt)("strong",{parentName:"p"},"A")," to ",(0,r.kt)("strong",{parentName:"p"},"D")," as above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"\n    FOR v, e IN OUTBOUND SHORTEST_PATH 'circles/A' TO 'circles/D' GRAPH 'traversalGraph' \n      RETURN [v._key, e._key]\n\n    FOR v, e IN OUTBOUND SHORTEST_PATH 'circles/A' TO 'circles/D' edges \n      RETURN [v._key, e._key]\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'  [ \n    [ \n      "A", \n      null \n    ], \n    [ \n      "B", \n      "66174" \n    ], \n    [ \n      "C", \n      "66176" \n    ], \n    [ \n      "D", \n      "66178" \n    ] \n  ]\n  [object C8ueryCursor, count: 4, cached: false, hasMore: false]\n  [ \n    [ \n      "A", \n      null \n    ], \n    [ \n      "B", \n      "66174" \n    ], \n    [ \n      "C", \n      "66176" \n    ], \n    [ \n      "D", \n      "66178" \n    ] \n  ]\n  [object C8QueryCursor, count: 4, cached: false, hasMore: false]\n')),(0,r.kt)("p",null,"We can see our expectations are fulfilled. We find the vertices in the correct ordering and the first edge is ",(0,r.kt)("em",{parentName:"p"},"null"),", because no edge is pointing to the start vertex on t his path."),(0,r.kt)("p",null,"We can also compute shortest paths based on documents found in collections:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FOR a IN circles FILTER a._key == 'A' \n  FOR d IN circles FILTER d._key == 'D' \n    FOR v, e IN \n      OUTBOUND SHORTEST_PATH a TO d \n      GRAPH 'traversalGraph' \n      RETURN [v._key, e._key]\n\nFOR a IN circles FILTER a._key == 'A' \n  FOR d IN circles FILTER d._key == 'D' \n    FOR v, e IN \n      OUTBOUND SHORTEST_PATH a TO d edges \n      RETURN [v._key, e._key]\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'  [ \n    [ \n      "A", \n      null \n    ], \n    [ \n      "B", \n      "66174" \n    ], \n    [ \n      "C", \n      "66176" \n    ], \n    [ \n      "D", \n      "66178" \n    ] \n  ]\n  [object C8QueryCursor, count: 4, cached: false, hasMore: false]\n  [ \n    [ \n      "A", \n      null \n    ], \n    [ \n      "B", \n      "66174" \n    ], \n    [ \n      "C", \n      "66176" \n    ], \n    [ \n      "D", \n      "66178" \n    ] \n  ]\n  [object C8QueryCursor, count: 4, cached: false, hasMore: false]\n')),(0,r.kt)("p",null,"And finally clean it up again."))}h.isMDXComponent=!0},91782:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/traversal_graph-a64cabebe07a017552f9a2f4414e6544.png"}}]);