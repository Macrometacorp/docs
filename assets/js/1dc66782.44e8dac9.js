"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[70695],{3905:(e,a,t)=>{t.d(a,{Zo:()=>c,kt:()=>u});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),d=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},c=function(e){var a=d(e.components);return n.createElement(s.Provider,{value:a},e.children)},h={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},p=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=d(t),u=r,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||l;return t?n.createElement(m,i(i({ref:a},c),{},{components:t})):n.createElement(m,i({ref:a},c))}));function u(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=p;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=t[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}p.displayName="MDXCreateElement"},16181:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var n=t(87462),r=(t(67294),t(3905));const l={sidebar_position:50,title:"Part 5 - Graph Traversal"},i=void 0,o={unversionedId:"queryworkers/c8ql/got-tutorial/graph-traversal",id:"queryworkers/c8ql/got-tutorial/graph-traversal",title:"Part 5 - Graph Traversal",description:"Two documents, such as a parent character document and a child character document, can be linked by an edge document and modeled as a graph. Edge documents are stored in Graph Edge collections and have two additional attributes: from and to. They reference any two documents by their document IDs (_id).",source:"@site/docs/queryworkers/c8ql/got-tutorial/graph-traversal.md",sourceDirName:"queryworkers/c8ql/got-tutorial",slug:"/queryworkers/c8ql/got-tutorial/graph-traversal",permalink:"/docs/queryworkers/c8ql/got-tutorial/graph-traversal",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/got-tutorial/graph-traversal.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{sidebar_position:50,title:"Part 5 - Graph Traversal"},sidebar:"defaultSidebar",previous:{title:"Part 4 - Import Traits and Merge",permalink:"/docs/queryworkers/c8ql/got-tutorial/import-and-merge"},next:{title:"Part 6 - Geospatial Queries",permalink:"/docs/queryworkers/c8ql/got-tutorial/geospatial-queries"}},s={},d=[{value:"ChildOf relations",id:"childof-relations",level:2},{value:"Create the Edges",id:"create-the-edges",level:2},{value:"Create a Graph Edge collection",id:"create-a-graph-edge-collection",level:3},{value:"Run Query",id:"run-query",level:3},{value:"Explanation of Graph Edge Query",id:"explanation-of-graph-edge-query",level:3},{value:"The Data Block",id:"the-data-block",level:4},{value:"Assign Relationships",id:"assign-relationships",level:4},{value:"Filter and Insert",id:"filter-and-insert",level:4},{value:"Traverse to the Parents",id:"traverse-to-the-parents",level:2},{value:"Traversal Query Explanation",id:"traversal-query-explanation",level:3},{value:"Traverse to the Children",id:"traverse-to-the-children",level:2},{value:"Traverse to the Grandchildren",id:"traverse-to-the-grandchildren",level:2},{value:"Traverse with Variable Depth",id:"traverse-with-variable-depth",level:2},{value:"Next Steps",id:"next-steps",level:2}],c={toc:d};function h(e){let{components:a,...l}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,l,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Two documents, such as a parent character document and a child character document, can be linked by an edge document and modeled as a graph. Edge documents are stored in Graph Edge collections and have two additional attributes: ",(0,r.kt)("inlineCode",{parentName:"p"},"_from")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_to"),". They reference any two documents by their document IDs (",(0,r.kt)("inlineCode",{parentName:"p"},"_id"),")."),(0,r.kt)("h2",{id:"childof-relations"},"ChildOf relations"),(0,r.kt)("p",null,"Our characters have the following relations between parents and children (first names only for a better overview):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"    Robb -> Ned\n   Sansa -> Ned\n    Arya -> Ned\n    Bran -> Ned\n     Jon -> Ned\n    Robb -> Catelyn\n   Sansa -> Catelyn\n    Arya -> Catelyn\n    Bran -> Catelyn\n   Jaime -> Tywin\n  Cersei -> Tywin\n  Tyrion -> Tywin\n Joffrey -> Jaime\n Joffrey -> Cersei\n")),(0,r.kt)("p",null,"Visualized as a graph:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ChildOf graph visualization",src:t(96676).Z,width:"800",height:"317"})),(0,r.kt)("h2",{id:"create-the-edges"},"Create the Edges"),(0,r.kt)("p",null,"To create the required edge documents to store these relations in the database, you can run a query that combines joining and filtering to match up the right character documents, then use their ",(0,r.kt)("inlineCode",{parentName:"p"},"_id")," attribute to insert an edge into an edge collection ",(0,r.kt)("em",{parentName:"p"},"ChildOf"),"."),(0,r.kt)("h3",{id:"create-a-graph-edge-collection"},"Create a Graph Edge collection"),(0,r.kt)("p",null,"Create a new ",(0,r.kt)("a",{parentName:"p",href:"/docs/collections/graph-edge/add-edges"},"Graph Edge collection")," called ",(0,r.kt)("strong",{parentName:"p"},"ChildOf"),"."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Click ",(0,r.kt)("strong",{parentName:"li"},"Data > Collections"),"."),(0,r.kt)("li",{parentName:"ol"},"Click ",(0,r.kt)("strong",{parentName:"li"},"New Collection"),"."),(0,r.kt)("li",{parentName:"ol"},"Click ",(0,r.kt)("strong",{parentName:"li"},"Graph Edge"),"."),(0,r.kt)("li",{parentName:"ol"},"Name the collection ",(0,r.kt)("strong",{parentName:"li"},"ChildOf")," and then click ",(0,r.kt)("strong",{parentName:"li"},"Create"),".")),(0,r.kt)("h3",{id:"run-query"},"Run Query"),(0,r.kt)("p",null,"Then run the following query in ",(0,r.kt)("strong",{parentName:"p"},"Queries"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET data = [\n    {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Robb", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Sansa", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Arya", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Bran", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Catelyn", "surname": "Stark" },\n        "child": { "name": "Robb", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Catelyn", "surname": "Stark" },\n        "child": { "name": "Sansa", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Catelyn", "surname": "Stark" },\n        "child": { "name": "Arya", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Catelyn", "surname": "Stark" },\n        "child": { "name": "Bran", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Jon", "surname": "Snow" }\n    }, {\n        "parent": { "name": "Tywin", "surname": "Lannister" },\n        "child": { "name": "Jaime", "surname": "Lannister" }\n    }, {\n        "parent": { "name": "Tywin", "surname": "Lannister" },\n        "child": { "name": "Cersei", "surname": "Lannister" }\n    }, {\n        "parent": { "name": "Tywin", "surname": "Lannister" },\n        "child": { "name": "Tyrion", "surname": "Lannister" }\n    }, {\n        "parent": { "name": "Cersei", "surname": "Lannister" },\n        "child": { "name": "Joffrey", "surname": "Baratheon" }\n    }, {\n        "parent": { "name": "Jaime", "surname": "Lannister" },\n        "child": { "name": "Joffrey", "surname": "Baratheon" }\n    }\n]\n\nFOR rel in data\n    LET parentId = FIRST(\n        FOR c IN Characters\n            FILTER c.name == rel.parent.name\n            FILTER c.surname == rel.parent.surname\n            LIMIT 1\n            RETURN c._id\n    )\n    LET childId = FIRST(\n        FOR c IN Characters\n            FILTER c.name == rel.child.name\n            FILTER c.surname == rel.child.surname\n            LIMIT 1\n            RETURN c._id\n    )\n    FILTER parentId != null AND childId != null\n    INSERT { _from: childId, _to: parentId } INTO ChildOf\n    RETURN NEW\n')),(0,r.kt)("p",null,"When you run the query, it returns a graph with data structures similar to those shown earlier and below. However, your graph has system-defined keys whereas the one shown here have user-defined keys."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"ChildOf_Graph",src:t(96676).Z,width:"800",height:"317"})),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Sometimes the two family structures generate overlapping one another. To separate them, click the ",(0,r.kt)("strong",{parentName:"p"},"Start layout animation")," play icon in the lower right corner of the Query Result. Click Stop after the diagrams separate.")),(0,r.kt)("p",null,"Your results should look similar to this graph."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Separated Graphs",src:t(8163).Z,width:"1530",height:"932"})),(0,r.kt)("h3",{id:"explanation-of-graph-edge-query"},"Explanation of Graph Edge Query"),(0,r.kt)("p",null,"The character documents don't have user-defined keys. If they had, it would allow us to create the edges more easily like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'INSERT { _from: "Characters/robb", _to: "Characters/ned" } INTO ChildOf\n')),(0,r.kt)("p",null,"However, creating the edges programmatically based on character names is a good exercise. This is what each part of the query did."),(0,r.kt)("h4",{id:"the-data-block"},"The Data Block"),(0,r.kt)("p",null,"Assign the relations in form of an array of objects with a ",(0,r.kt)("em",{parentName:"p"},"parent")," and a ",(0,r.kt)("em",{parentName:"p"},"child")," attribute each, both with sub-attributes ",(0,r.kt)("em",{parentName:"p"},"name")," and ",(0,r.kt)("em",{parentName:"p"},"surname"),", to a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),". Basically, each object is a parent and child pairing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET data = [\n    {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Robb", "surname": "Stark" }\n    }, {\n        "parent": { "name": "Ned", "surname": "Stark" },\n        "child": { "name": "Sansa", "surname": "Stark" }\n    ...\n')),(0,r.kt)("h4",{id:"assign-relationships"},"Assign Relationships"),(0,r.kt)("p",null,"The FOR loop creates data connecting the relation data in the block above and the names in Characters."),(0,r.kt)("p",null,"For each element in this array, assign a relation to a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"rel")," and execute the subsequent instructions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Assign the result of an expression to a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"parentId"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Take the first element of a sub-query result. Sub-queries are enclosed by parentheses, but here they are also a function call.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For each document in the Characters collection, assign the document to a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"c"),"."),(0,r.kt)("li",{parentName:"ul"},"Apply two filter conditions: the name in the character document must equal the parent name in ",(0,r.kt)("inlineCode",{parentName:"li"},"rel"),", and the surname must also equal the surname give in the relations data."),(0,r.kt)("li",{parentName:"ul"},"Stop after the first match for efficiency."),(0,r.kt)("li",{parentName:"ul"},"Return the ID of the character document. The result of the sub-query is an array with one element, ",(0,r.kt)("inlineCode",{parentName:"li"},"FIRST()")," takes this element and assigns it to the ",(0,r.kt)("inlineCode",{parentName:"li"},"parentId")," variable."))))),(0,r.kt)("li",{parentName:"ul"},"Assign the result of an expression to a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"childId"),". A sub-query is used to find the child character document and the ID is returned, in the same way as the parent document ID (see above)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR rel in data\n    LET parentId = FIRST(\n        FOR c IN Characters\n            FILTER c.name == rel.parent.name\n            FILTER c.surname == rel.parent.surname\n            LIMIT 1\n            RETURN c._id\n    )\n    LET childId = FIRST(\n        FOR c IN Characters\n            FILTER c.name == rel.child.name\n            FILTER c.surname == rel.child.surname\n            LIMIT 1\n            RETURN c._id\n    )\n")),(0,r.kt)("h4",{id:"filter-and-insert"},"Filter and Insert"),(0,r.kt)("p",null,"The last part of the query inserts the connections created with the FOR loops into ChildOf and returns the raw results."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If either or both of the sub-queries were unable to find a match, skip the current relation, because two IDs for both ends of an edge are required to create one."),(0,r.kt)("li",{parentName:"ul"},"Insert a new edge document into the ChildOf collection, with the edge going from ",(0,r.kt)("inlineCode",{parentName:"li"},"childId")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"parentId")," and no other attributes."),(0,r.kt)("li",{parentName:"ul"},"Return the new edge document.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"    FILTER parentId != null AND childId != null\n    INSERT { _from: childId, _to: parentId } INTO ChildOf\n    RETURN NEW\n")),(0,r.kt)("h2",{id:"traverse-to-the-parents"},"Traverse to the Parents"),(0,r.kt)("p",null,"Now that edges link character documents (vertices), you have a graph that can query to find out who the parents are of another character. In graph terms, you'll start at a vertex and follow the edges to other vertices with a ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/graphs/traversals"},"graph traversal"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR c IN Characters\n    FILTER c.name == "Bran"\n    FOR v IN 1..1 OUTBOUND c ChildOf\n        RETURN v.name\n')),(0,r.kt)("p",null,"The start vertex is followed by ",(0,r.kt)("inlineCode",{parentName:"p"},"ChildOf"),", which is our edge collection. The example query returns only the name of each parent to keep the result short:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "Ned",\n  "Catelyn"\n]\n')),(0,r.kt)("h3",{id:"traversal-query-explanation"},"Traversal Query Explanation"),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR")," loop doesn't iterate over a collection or an array, it walks the graph and iterates over the connected vertices it finds, with the vertex document assigned to a variable (here: ",(0,r.kt)("inlineCode",{parentName:"p"},"v"),"). It can also emit the edges it walked as well as the full path from start to end to ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/graphs/traversals#syntax"},"another two variables"),"."),(0,r.kt)("p",null,"In above query, the traversal is restricted to a minimum and maximum traversal depth of 1 (how many steps to take from the start vertex), and to only follow edges in ",(0,r.kt)("inlineCode",{parentName:"p"},"OUTBOUND")," direction. The edges point from child to parent, and the parent is one step away from the child, thus it returns the parents of the child we start at."),(0,r.kt)("p",null,"You could also do this in two steps, using the document ID."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Run the following code block to return Bran's ID."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR c IN Characters\n    FILTER c.name == "Bran"\n    RETURN c._id\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Use the ID returned in the following code block to return parent names."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR v IN 1..1 OUTBOUND "Characters/2901776" ChildOf\n    RETURN v.name\n')))),(0,r.kt)("p",null,"The same result will be returned for Robb, Arya, and Sansa as starting point. For Jon Snow, it will only be Ned."),(0,r.kt)("h2",{id:"traverse-to-the-children"},"Traverse to the Children"),(0,r.kt)("p",null,"You can also walk from a parent in reverse edge direction (",(0,r.kt)("inlineCode",{parentName:"p"},"INBOUND")," that is) to the children:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR c IN Characters\n    FILTER c.name == "Ned"\n    FOR v IN 1..1 INBOUND c ChildOf\n        RETURN v.name\n')),(0,r.kt)("p",null,"This returns a list of Ned's children:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "Robb",\n  "Sansa",\n  "Jon",\n  "Arya",\n  "Bran"\n]\n')),(0,r.kt)("h2",{id:"traverse-to-the-grandchildren"},"Traverse to the Grandchildren"),(0,r.kt)("p",null,"The Lannister family has relations that span from parent to grandchild. Let's change the traversal depth to return grandchildren, which means to go exactly two steps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR c IN Characters\n    FILTER c.name == "Tywin"\n    FOR v IN 2..2 INBOUND c ChildOf\n        RETURN v.name\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "Joffrey",\n  "Joffrey"\n]\n')),(0,r.kt)("p",null,"It might be a bit unexpected that Joffrey is returned twice. However, if you look at the graph visualization, you can see that multiple paths lead from Joffrey (bottom right) to Tywin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"Tywin <- Jaime <- Joffrey\nTywin <- Cersei <- Joffrey\n")),(0,r.kt)("p",null,"As a quick fix, change the last line of the query to ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT v.name")," to return each value only once. Keep in mind though, that there are ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/graphs/traversals#syntax"},"traversal options")," to suppress duplicate vertices early on."),(0,r.kt)("h2",{id:"traverse-with-variable-depth"},"Traverse with Variable Depth"),(0,r.kt)("p",null,"To return the parents and grandparents of Joffrey, you can walk edges in ",(0,r.kt)("inlineCode",{parentName:"p"},"OUTBOUND")," direction and adjust the traversal depth to go at least 1 step, and 2 at most:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR c IN Characters\n    FILTER c.name == "Joffrey"\n    FOR v IN 1..2 OUTBOUND c ChildOf\n        RETURN DISTINCT v.name\n')),(0,r.kt)("p",null,"This returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "Cersei",\n  "Tywin",\n  "Jaime"\n]\n')),(0,r.kt)("p",null,"If the dataset had deeper family trees, it would only be a matter of changing the depth values to query for great-grandchildren and similar relations."),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"Great job! You can now create edges and traverse graph relationships. When you're ready, continue the tutorial in ",(0,r.kt)("a",{parentName:"p",href:"geospatial-queries"},"Part 6 - Geospatial Queries"),"."))}h.isMDXComponent=!0},96676:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/ChildOf_Graph-cb14d112683339e26adbbbf1be3a6f6c.png"},8163:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/graphs-separate-7fc1fc26f3a080e950248bf92c6dbd1e.png"}}]);