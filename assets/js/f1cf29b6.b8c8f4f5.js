"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[48746],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),u=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,h=d["".concat(i,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(h,s(s({ref:n},c),{},{components:t})):a.createElement(h,s({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var u=2;u<o;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},17318:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=t(87462),r=(t(67294),t(3905));const o={sidebar_position:7,title:"Joins"},s=void 0,l={unversionedId:"queryworkers/c8ql/examples/joins",id:"queryworkers/c8ql/examples/joins",title:"Joins",description:"The two common scenarios when you want to join documents of collections are:",source:"@site/docs/queryworkers/c8ql/examples/joins.md",sourceDirName:"queryworkers/c8ql/examples",slug:"/queryworkers/c8ql/examples/joins",permalink:"/docs/queryworkers/c8ql/examples/joins",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/examples/joins.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Joins"},sidebar:"defaultSidebar",previous:{title:"Grouping",permalink:"/docs/queryworkers/c8ql/examples/grouping"},next:{title:"Multiple Path Search",permalink:"/docs/queryworkers/c8ql/examples/multiple-path-search"}},i={},u=[{value:"One-To-Many",id:"one-to-many",level:2},{value:"Many-To-Many",id:"many-to-many",level:2},{value:"Embedded Lists",id:"embedded-lists",level:3},{value:"Using Edge Collections",id:"using-edge-collections",level:3},{value:"More examples",id:"more-examples",level:2},{value:"Join tuples",id:"join-tuples",level:3},{value:"Horizontal lists",id:"horizontal-lists",level:3},{value:"Self joins",id:"self-joins",level:3},{value:"Outer joins",id:"outer-joins",level:3},{value:"Index usage",id:"index-usage",level:3},{value:"Pitfalls",id:"pitfalls",level:3}],c={toc:u};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The two common scenarios when you want to join documents of collections are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"One-to-Many"),": You may have a collection ",(0,r.kt)("em",{parentName:"p"},"users")," and a collection ",(0,r.kt)("em",{parentName:"p"},"cities"),". A user lives in a city and you need the city information during a query about the user.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Many-To-Many"),": You may have a collection ",(0,r.kt)("em",{parentName:"p"},"authors")," and ",(0,r.kt)("em",{parentName:"p"},"books"),". An author can write many books and a book can have many authors. You want to return a list of books with their authors. Therefore you need to join the authors and books."))),(0,r.kt)("p",null,"Unlike many NoSQL databases, GDN does support joins in C8QL queries. This is similar to the way traditional relational databases handle this. However, because documents allow for more flexibility, joins are also more flexible. The following sections provide solutions for common questions."),(0,r.kt)("p",null,"So far we have only dealt with one collection (",(0,r.kt)("em",{parentName:"p"},"users"),") at a time. We also have a collection ",(0,r.kt)("em",{parentName:"p"},"relations")," that stores relationships between users. We will now use this extra collection to create a result from two collections."),(0,r.kt)("p",null,"First of all, we'll query a few users together with their friends' ids. For that, we'll use all ",(0,r.kt)("em",{parentName:"p"},"relations")," that have a value of ",(0,r.kt)("em",{parentName:"p"},"friend")," in their ",(0,r.kt)("em",{parentName:"p"},"type")," attribute. Relationships are established by using the ",(0,r.kt)("em",{parentName:"p"},"friendOf")," and ",(0,r.kt)("em",{parentName:"p"},"thisUser")," attributes in the ",(0,r.kt)("em",{parentName:"p"},"relations")," collection, which point to the ",(0,r.kt)("em",{parentName:"p"},"userId")," values in the ",(0,r.kt)("em",{parentName:"p"},"users")," collection."),(0,r.kt)("h2",{id:"one-to-many"},"One-To-Many"),(0,r.kt)("p",null,"You have a collection called ",(0,r.kt)("inlineCode",{parentName:"p"},"users"),". Users live in city and a city is identified by its primary key. In principle you can embedded the city document into the users document and be happy with it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "_id" : "users/2151975421",\n  "_key" : "2151975421",\n  "_rev" : "2151975421",\n  "name" : {\n    "first" : "John",\n    "last" : "Doe"\n  },\n  "city" : {\n    "name" : "Metropolis"\n  }\n}\n')),(0,r.kt)("p",null,"This works well for many use cases. Now assume, that you have additional information about the city, like the number of people living in it. It would be impractical to change each and every user document if this numbers changes. Therefore it is good idea to hold the city information in a separate collection."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'cities.document("cities/2241300989");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "population" : 1000, \n  "name" : "Metropolis", \n  "_id" : "cities/2241300989", \n  "_rev" : "2241300989", \n  "_key" : "2241300989" \n}\n')),(0,r.kt)("p",null,"Now you instead of embedding the city directly in the user document, you can use the key of the city."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'users.document("users/2290649597");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "name" : { \n    "first" : "John", \n    "last" : "Doe" \n  }, \n  "city" : "cities/2241300989", \n  "_id" : "users/2290649597", \n  "_rev" : "2290649597", \n  "_key" : "2290649597" \n}\n')),(0,r.kt)("p",null,"We can now join these two collections very easily."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FOR c IN cities\n    FILTER u.city == c._id RETURN { user: u, city: c }\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "user" : { \n      "name" : { \n        "first" : "John", \n        "last" : "Doe" \n      }, \n      "city" : "cities/2241300989", \n      "_id" : "users/2290649597", \n      "_rev" : "2290649597", \n      "_key" : "2290649597" \n    }, \n    "city" : { \n      "population" : 1000, \n      "name" : "Metropolis", \n      "_id" : "cities/2241300989", \n      "_rev" : "2241300989", \n      "_key" : "2241300989" \n    } \n  } \n]\n')),(0,r.kt)("p",null,"Unlike SQL there is no special ",(0,r.kt)("inlineCode",{parentName:"p"},"JOIN")," keyword. The optimizer ensures that the primary index is used in the above query."),(0,r.kt)("p",null,"However, very often it is much more convenient for the client of the query if a single document would be returned, where the city information is embedded in the user document - as in the simple example above. With C8QL there you do not need to forgo this simplification."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FOR c IN cities\n    FILTER u.city == c._id RETURN merge(u, {city: c})\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "users/2290649597", \n    "_key" : "2290649597", \n    "_rev" : "2290649597", \n    "name" : { \n      "first" : "John", \n      "last" : "Doe" \n    }, \n    "city" : { \n      "_id" : "cities/2241300989", \n      "_key" : "2241300989", \n      "_rev" : "2241300989", \n      "population" : 1000, \n      "name" : "Metropolis" \n    } \n  } \n]\n')),(0,r.kt)("p",null,"So you can have both: the convenient representation of the result for your client and the flexibility of joins for your data model."),(0,r.kt)("h2",{id:"many-to-many"},"Many-To-Many"),(0,r.kt)("p",null,"In the relational word you need a third table to model the many-to-many relation. In GDN you have a choice depending on the information you are going to store and the type of questions you are going to ask."),(0,r.kt)("p",null,'Assume that authors are stored in one collection and books in a second. If all you need is "which are the authors of a book" then you can easily model this as a list attribute in users.'),(0,r.kt)("p",null,'If you want to store more information, for example which author wrote which page in a conference proceeding, or if you also want to know "which books were written by which author", you can use edge collections. This is very similar to the "join table" from the relational world.'),(0,r.kt)("h3",{id:"embedded-lists"},"Embedded Lists"),(0,r.kt)("p",null,"If you only want to store the authors of a book, you can embed them as list in the book document. There is no need for a separate collection."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"authors.toArray()\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "authors/2661190141", \n    "_key" : "2661190141", \n    "_rev" : "2661190141", \n    "name" : { \n      "first" : "Maxima", \n      "last" : "Musterfrau" \n    } \n  }, \n  { \n    "_id" : "authors/2658437629", \n    "_key" : "2658437629", \n    "_rev" : "2658437629", \n    "name" : { \n      "first" : "John", \n      "last" : "Doe" \n    } \n  } \n]\n')),(0,r.kt)("p",null,"You can query books"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'"FOR b IN books RETURN b"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "books/2681506301", \n    "_key" : "2681506301", \n    "_rev" : "2681506301", \n    "title" : "The beauty of JOINS", \n    "authors" : [ \n      "authors/2661190141", \n      "authors/2658437629" \n    ] \n  } \n]\n')),(0,r.kt)("p",null,"and join the authors in a very similar manner given in the one-to-many section."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\n  LET a = (FOR x IN b.authors \n    FOR a IN authors FILTER x == a._id RETURN a)\n  RETURN { book: b, authors: a }\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "book" : { \n      "title" : "The beauty of JOINS", \n      "authors" : [ \n        "authors/2661190141", \n        "authors/2658437629" \n      ], \n      "_id" : "books/2681506301", \n      "_rev" : "2681506301", \n      "_key" : "2681506301" \n    }, \n    "authors" : [ \n      { \n        "name" : { \n          "first" : "Maxima", \n          "last" : "Musterfrau" \n        }, \n        "_id" : "authors/2661190141", \n        "_rev" : "2661190141", \n        "_key" : "2661190141" \n      }, \n      { \n        "name" : { \n          "first" : "John", \n          "last" : "Doe" \n        }, \n        "_id" : "authors/2658437629", \n        "_rev" : "2658437629", \n        "_key" : "2658437629" \n      } \n    ] \n  } \n]\n')),(0,r.kt)("p",null,"\u2026 or embed the authors directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books LET a = (\n  FOR x IN b.authors \n    FOR a IN authors FILTER x == a._id RETURN a)\n  RETURN merge(b, { authors: a })\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "books/2681506301", \n    "_key" : "2681506301", \n    "_rev" : "2681506301", \n    "title" : "The beauty of JOINS", \n    "authors" : [ \n      { \n        "_id" : "authors/2661190141", \n        "_key" : "2661190141", \n        "_rev" : "2661190141", \n        "name" : { \n          "first" : "Maxima", \n          "last" : "Musterfrau" \n        } \n      }, \n      { \n        "_id" : "authors/2658437629", \n        "_key" : "2658437629", \n        "_rev" : "2658437629", \n        "name" : { \n          "first" : "John", \n          "last" : "Doe" \n        } \n      } \n    ] \n  } \n]\n')),(0,r.kt)("h3",{id:"using-edge-collections"},"Using Edge Collections"),(0,r.kt)("p",null,"If you also want to query which books are written by a given author, embedding authors in the book document is possible, but it is more efficient to use a edge collections for speed."),(0,r.kt)("p",null,"Or you are publishing a proceeding, then you want to store the pages the author has written as well. This information can be stored in the edge document."),(0,r.kt)("p",null,"First create the users"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'db.create("authors");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'[Collection 2926807549, "authors" (type document, status loaded)]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'authors.save({ name: { first: "John", last: "Doe" } })\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "authors/2935261693", \n  "_rev" : "2935261693", \n  "_key" : "2935261693" \n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'authors.save({ name: { first: "Maxima", last: "Musterfrau" } })\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "authors/2938210813", \n  "_rev" : "2938210813", \n  "_key" : "2938210813" \n}\n')),(0,r.kt)("p",null,"Now create the books without any author information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'db.create("books");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[Collection 2928380413, "books" (type document, status loaded)]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'books.save({ title: "The beauty of JOINS" });\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "books/2980088317", \n  "_rev" : "2980088317", \n  "_key" : "2980088317" \n}\n')),(0,r.kt)("p",null,"An edge collection is now used to link authors and books."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'db.createEdgeCollection("written");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[Collection 2931132925, "written" (type edge, status loaded)]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'written.save("authors/2935261693", "books/2980088317", { pages: "1-10" })\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "written/3006237181", \n  "_rev" : "3006237181", \n  "_key" : "3006237181" \n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'written.save("authors/2938210813", "books/2980088317", { pages: "11-20" })\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "written/3012856317", \n  "_rev" : "3012856317", \n  "_key" : "3012856317" \n}\n')),(0,r.kt)("p",null,"In order to get all books with their authors you can use a ",(0,r.kt)("a",{parentName:"p",href:"../graphs/traversals#working-with-collection-sets"},"graph traversal")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authorsByBook = (\n  FOR author, writtenBy IN INBOUND b written\n    RETURN {\n        vertex: author,\n        edge: writtenBy\n    }\n)\nRETURN {\n    book: b,\n    authors: authorsByBook\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "book" : {\n      "_key" : "2980088317",\n      "_id" : "books/2980088317",\n      "_rev" : "2980088317",\n      "title" : "The beauty of JOINS"\n    },\n    "authors" : [\n      {\n        "vertex" : {\n          "_key" : "2935261693",\n          "_id" : "authors/2935261693",\n          "_rev" : "2935261693",\n          "name" : {\n            "first" : "John",\n            "last" : "Doe"\n          }\n        },\n        "edge" : {\n          "_key" : "2935261693",\n          "_id" : "written/2935261693",\n          "_from" : "authors/2935261693",\n          "_to" : "books/2980088317",\n          "_rev" : "3006237181",\n          "pages" : "1-10"\n        }\n      },\n      {\n        "vertex" : {\n          "_key" : "2938210813",\n          "_id" : "authors/2938210813",\n          "_rev" : "2938210813",\n          "name" : {\n            "first" : "Maxima",\n            "last" : "Musterfrau"\n          }\n        },\n        "edge" : {\n          "_key" : "6833274",\n          "_id" : "written/6833274",\n          "_from" : "authors/2938210813",\n          "_to" : "books/2980088317",\n          "_rev" : "3012856317",\n          "pages" : "11-20"\n        }\n      }\n    ]\n  }\n]\n')),(0,r.kt)("p",null,"Or if you want only the information stored in the vertices."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authorsByBook = (\n    FOR author IN INBOUND b written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN author\n)\nRETURN {\n    book: b,\n    authors: authorsByBook\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "book" : {\n      "_key" : "2980088317",\n      "_id" : "books/2980088317",\n      "_rev" : "2980088317",\n      "title" : "The beauty of JOINS"\n    },\n    "authors" : [\n      {\n        "_key" : "2938210813",\n        "_id" : "authors/2938210813",\n        "_rev" : "2938210813",\n        "name" : {\n          "first" : "Maxima",\n          "last" : "Musterfrau"\n        }\n      },\n      {\n        "_key" : "2935261693",\n        "_id" : "authors/2935261693",\n        "_rev" : "2935261693",\n        "name" : {\n          "first" : "John",\n          "last" : "Doe"\n        }\n      }\n    ]\n  }\n]\n')),(0,r.kt)("p",null,"Or again embed the authors directly into the book document."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authors = (\n    FOR author IN INBOUND b written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN author\n)\nRETURN MERGE(b, {authors: authors})\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "_id" : "books/2980088317",\n    "_key" : "2980088317",\n    "_rev" : "2980088317",\n    "title" : "The beauty of JOINS",\n    "authors" : [\n      {\n        "_key" : "2938210813",\n        "_id" : "authors/2938210813",\n        "_rev" : "2938210813",\n        "name" : {\n          "first" : "Maxima",\n          "last" : "Musterfrau"\n        }\n      },\n      {\n        "_key" : "2935261693",\n        "_id" : "authors/2935261693",\n        "_rev" : "2935261693",\n        "name" : {\n          "first" : "John",\n          "last" : "Doe"\n        }\n      }\n    ]\n  }\n]\n')),(0,r.kt)("p",null,"If you need the authors and their books, simply reverse the direction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR a IN authors\nLET booksByAuthor = (\n    FOR b IN OUTBOUND a written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN b\n)\nRETURN MERGE(a, {books: booksByAuthor})\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "_id" : "authors/2935261693",\n    "_key" : "2935261693",\n    "_rev" : "2935261693",\n    "name" : {\n      "first" : "John",\n      "last" : "Doe"\n    },\n    "books" : [\n      {\n        "_key" : "2980088317",\n        "_id" : "books/2980088317",\n        "_rev" : "2980088317",\n        "title" : "The beauty of JOINS"\n      }\n    ]\n  },\n  {\n    "_id" : "authors/2938210813",\n    "_key" : "2938210813",\n    "_rev" : "2938210813",\n    "name" : {\n      "first" : "Maxima",\n      "last" : "Musterfrau"\n    },\n    "books" : [\n      {\n        "_key" : "2980088317",\n        "_id" : "books/2980088317",\n        "_rev" : "2980088317",\n        "title" : "The beauty of JOINS"\n      }\n    ]\n  }\n]\n')),(0,r.kt)("h2",{id:"more-examples"},"More examples"),(0,r.kt)("h3",{id:"join-tuples"},"Join tuples"),(0,r.kt)("p",null,"We will start with a SQL-ish result set and return each tuple (user name, friends userId) separately. The C8QL query to generate such result is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'    FOR u IN users\n      FILTER u.active == true\n      LIMIT 0, 4\n      FOR f IN relations\n        FILTER f.type == @friend && f.friendOf == u.userId\n        RETURN {\n          "user" : u.name,\n          "friendId" : f.thisUser\n        }\n    @BV {\n    friend: "friend"\n    }\n')),(0,r.kt)("p",null,"We iterate over the collection users. Only the 'active' users will be examined. For each of these users we will search for up to 4 friends. We locate friends by comparing the ",(0,r.kt)("em",{parentName:"p"},"userId")," of our current user with the ",(0,r.kt)("em",{parentName:"p"},"friendOf")," attribute of the ",(0,r.kt)("em",{parentName:"p"},"relations")," document. For each of those relations found we return the users name and the userId of the friend."),(0,r.kt)("h3",{id:"horizontal-lists"},"Horizontal lists"),(0,r.kt)("p",null,"Note that in the above result, a user can be returned multiple times. This is the SQL way of returning data. If this is not desired, the friends' ids of each user can be returned in a horizontal list. This will return each user at most once."),(0,r.kt)("p",null,"The C8QL query for doing so is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  FILTER u.active == true LIMIT 0, 4\n  RETURN {\n    "user" : u.name,\n    "friendIds" : (\n      FOR f IN relations\n        FILTER f.friendOf == u.userId && f.type == "friend"\n        RETURN f.thisUser\n    )\n  }\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail",\n    "friendIds" : [\n      108,\n      102,\n      106\n    ]\n  },\n  {\n    "user" : "Fred",\n    "friendIds" : [\n      209\n    ]\n  },\n  {\n    "user" : "Mary",\n    "friendIds" : [\n      207,\n      104\n    ]\n  },\n  {\n    "user" : "Mariah",\n    "friendIds" : [\n      203,\n      205\n    ]\n  }\n]\n')),(0,r.kt)("p",null,"In this query we are still iterating over the users in the ",(0,r.kt)("em",{parentName:"p"},"users")," collection and for each matching user we are executing a subquery to create the matching list of related users."),(0,r.kt)("h3",{id:"self-joins"},"Self joins"),(0,r.kt)("p",null,'To not only return friend ids but also the names of friends, we could "join" the ',(0,r.kt)("em",{parentName:"p"},"users"),' collection once more (something like a "self join"):'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  FILTER u.active == true\n  LIMIT 0, 4\n  RETURN {\n    "user" : u.name,\n    "friendIds" : (\n      FOR f IN relations\n        FILTER f.friendOf == u.userId && f.type == "friend"\n        FOR u2 IN users\n          FILTER f.thisUser == u2.useId\n          RETURN u2.name\n    )\n  }\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail",\n    "friendIds" : [\n      "Jim",\n      "Jacob",\n      "Daniel"\n    ]\n  },\n  {\n    "user" : "Fred",\n    "friendIds" : [\n      "Mariah"\n    ]\n  },\n  {\n    "user" : "Mary",\n    "friendIds" : [\n      "Isabella",\n      "Michael"\n    ]\n  },\n  {\n    "user" : "Mariah",\n    "friendIds" : [\n      "Madison",\n      "Eva"\n    ]\n  }\n]\n')),(0,r.kt)("p",null,"This query will then again in term fetch the clear text name of the friend from the users collection. So here we iterate the users collection, and for each hit the relations collection, and for each hit once more the users collection."),(0,r.kt)("h3",{id:"outer-joins"},"Outer joins"),(0,r.kt)("p",null,"Lets find the lonely people in our database - those without friends."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'\nFOR user IN users\n  LET friendList = (\n    FOR f IN relations\n      FILTER f.friendOf == u.userId\n      RETURN 1\n  )\n  FILTER LENGTH(friendList) == 0\n  RETURN { "user" : user.name }\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail"\n  },\n  {\n    "user" : "Fred"\n  }\n]\n')),(0,r.kt)("p",null,"So, for each user we pick the list of their friends and count them. The ones where count equals zero are the lonely people. Using ",(0,r.kt)("em",{parentName:"p"},"RETURN 1")," in the subquery saves even more precious CPU cycles and gives the optimizer more alternatives."),(0,r.kt)("h3",{id:"index-usage"},"Index usage"),(0,r.kt)("p",null,"Especially on joins you should make sure indices can be used to speed up your query. Please note that sparse indices don't qualify for joins:"),(0,r.kt)("p",null,"In joins you typically would also want to join documents not containing the property you join with. However sparse indices don't contain references to documents that don't contain the indexed attributes - thus they would be missing from the join operation. For that reason you should provide non-sparse indices. "),(0,r.kt)("h3",{id:"pitfalls"},"Pitfalls"),(0,r.kt)("p",null,"Since we're free of schemata, there is by default no way to tell the format of the documents. So, if your documents don't contain an attribute, it defaults to null. We can however check our data for accuracy like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"RETURN LENGTH(FOR u IN users FILTER u.userId == null RETURN 1)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"[\n  10000\n]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"RETURN LENGTH(FOR f IN relations FILTER f.friendOf == null RETURN 1)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"[\n  10000\n]\n")),(0,r.kt)("p",null,"So if the above queries return 10k matches each, the result of the Join tuples query will become 100,000,000 items larger and use much memory plus computation time. So it is generally a good idea to revalidate that the criteria for your join conditions exist."),(0,r.kt)("p",null,"Using indices on the properties can speed up the operation significantly. You can use the explain helper to revalidate your query actually uses them."),(0,r.kt)("p",null,"If you work with joins on edge collections you would typically aggregate over the internal fields ",(0,r.kt)("em",{parentName:"p"},"_id"),", ",(0,r.kt)("em",{parentName:"p"},"_from")," and ",(0,r.kt)("em",{parentName:"p"},"_to")," (where ",(0,r.kt)("em",{parentName:"p"},"_id")," equals ",(0,r.kt)("em",{parentName:"p"},"userId"),", ",(0,r.kt)("em",{parentName:"p"},"_from")," ",(0,r.kt)("em",{parentName:"p"},"friendOf")," and ",(0,r.kt)("em",{parentName:"p"},"_to")," would be ",(0,r.kt)("em",{parentName:"p"},"thisUser")," in our examples). GDN implicitly creates indices on them."))}p.isMDXComponent=!0}}]);