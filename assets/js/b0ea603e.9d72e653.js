"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[30256],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(a),d=r,h=c["".concat(p,".").concat(d)]||c[d]||u[d]||i;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},70601:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(87462),r=(a(67294),a(3905));const i={sidebar_position:9,title:"COLLECT"},o=void 0,l={unversionedId:"queryworkers/c8ql/operations/collect",id:"queryworkers/c8ql/operations/collect",title:"COLLECT",description:"The COLLECT keyword can be used to group an array by one or multiple group criteria.",source:"@site/docs/queryworkers/c8ql/operations/collect.md",sourceDirName:"queryworkers/c8ql/operations",slug:"/queryworkers/c8ql/operations/collect",permalink:"/docs/queryworkers/c8ql/operations/collect",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/operations/collect.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"COLLECT"},sidebar:"defaultSidebar",previous:{title:"LET",permalink:"/docs/queryworkers/c8ql/operations/let"},next:{title:"REMOVE",permalink:"/docs/queryworkers/c8ql/operations/remove"}},p={},s=[{value:"Grouping syntaxes",id:"grouping-syntaxes",level:2},{value:"Discarding obsolete variables",id:"discarding-obsolete-variables",level:2},{value:"Group length calculation",id:"group-length-calculation",level:2},{value:"Aggregation",id:"aggregation",level:2},{value:"COLLECT variants",id:"collect-variants",level:2},{value:"Setting COLLECT options",id:"setting-collect-options",level:2},{value:"COLLECT vs. RETURN DISTINCT",id:"collect-vs-return-distinct",level:2}],m={toc:s};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," keyword can be used to group an array by one or multiple group criteria. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement will eliminate all local variables in the current scope. After ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," only the variables introduced by ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," itself are available."),(0,r.kt)("p",null,"There are several syntax variants for ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," operations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"COLLECT variableName = expression\nCOLLECT variableName = expression INTO groupsVariable\nCOLLECT variableName = expression INTO groupsVariable = projectionExpression\nCOLLECT variableName = expression INTO groupsVariable KEEP keepVariable\nCOLLECT variableName = expression WITH COUNT INTO countVariable\nCOLLECT variableName = expression AGGREGATE variableName = aggregateExpression\nCOLLECT variableName = expression AGGREGATE variableName = aggregateExpression INTO groupsVariable\nCOLLECT AGGREGATE variableName = aggregateExpression\nCOLLECT AGGREGATE variableName = aggregateExpression INTO groupsVariable\nCOLLECT WITH COUNT INTO countVariable\n")),(0,r.kt)("p",null,"All variants can optionally end with an ",(0,r.kt)("inlineCode",{parentName:"p"},"OPTIONS { \u2026 }")," clause."),(0,r.kt)("h2",{id:"grouping-syntaxes"},"Grouping syntaxes"),(0,r.kt)("p",null,"The first syntax form of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," only groups the result by the defined group criteria specified in ",(0,r.kt)("em",{parentName:"p"},"expression"),". In order to further process the results produced by ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),", a new variable (specified by ",(0,r.kt)("em",{parentName:"p"},"variableName"),") is introduced. This variable contains the group value."),(0,r.kt)("p",null,"Here's an example query that find the distinct values in ",(0,r.kt)("em",{parentName:"p"},"u.city")," and makes them available in variable ",(0,r.kt)("em",{parentName:"p"},"city"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT city = u.city\n  RETURN { \n    "city" : city \n  }\n')),(0,r.kt)("p",null,"The second form does the same as the first form, but additionally introduces a variable (specified by ",(0,r.kt)("em",{parentName:"p"},"groupsVariable"),") that contains all elements that fell into the group. This works as follows: The ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," variable is an array containing as many elements as there are in the group. Each member of that array is a JSON object in which the value of every variable that is defined in the C8QL query is bound to the corresponding attribute. "),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This considers all variables that are defined before the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement, but not those on the top level (outside of any ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR"),"), unless the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement is itself on the top level, in which case all variables are taken. ")),(0,r.kt)("p",null,"Furthermore note that it is possible that the optimizer moves ",(0,r.kt)("inlineCode",{parentName:"p"},"LET")," statements out of ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR")," statements to improve performance. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT city = u.city INTO groups\n  RETURN { \n    "city" : city, \n    "usersInCity" : groups \n  }\n')),(0,r.kt)("p",null,"In the above example, the array ",(0,r.kt)("em",{parentName:"p"},"users")," will be grouped by the attribute ",(0,r.kt)("em",{parentName:"p"},"city"),". The result is a new array of documents, with one element per distinct ",(0,r.kt)("em",{parentName:"p"},"u.city")," value. The elements from the original array (here: ",(0,r.kt)("em",{parentName:"p"},"users"),") per city are made available in the variable ",(0,r.kt)("em",{parentName:"p"},"groups"),". This is due to the ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO")," clause."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," also allows specifying multiple group criteria. Individual group criteria can be separated by commas:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT country = u.country, city = u.city INTO groups\n  RETURN { \n    "country" : country, \n    "city" : city, \n    "usersInCity" : groups \n  }\n')),(0,r.kt)("p",null,"In the above example, the array ",(0,r.kt)("em",{parentName:"p"},"users")," is grouped by country first and then by city, and for each distinct combination of country and city, the users will be returned."),(0,r.kt)("h2",{id:"discarding-obsolete-variables"},"Discarding obsolete variables"),(0,r.kt)("p",null,"The third form of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," allows rewriting the contents of the ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," using an arbitrary ",(0,r.kt)("em",{parentName:"p"},"projectionExpression"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT country = u.country, city = u.city INTO groups = u.name\n  RETURN { \n    "country" : country, \n    "city" : city, \n    "userNames" : groups \n  }\n')),(0,r.kt)("p",null,"In the above example, only the ",(0,r.kt)("em",{parentName:"p"},"projectionExpression")," is ",(0,r.kt)("em",{parentName:"p"},"u.name"),". Therefore, only this attribute is copied into the ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," for each document. This is probably much more efficient than copying all variables from the scope into the ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," as it would happen without a ",(0,r.kt)("em",{parentName:"p"},"projectionExpression"),"."),(0,r.kt)("p",null,"The expression following ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO")," can also be used for arbitrary computations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT country = u.country, city = u.city INTO groups = { \n    "name" : u.name, \n    "isActive" : u.status == "active"\n  }\n  RETURN { \n    "country" : country, \n    "city" : city, \n    "usersInCity" : groups \n  }\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," also provides an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," clause that can be used to control which variables will be copied into the variable created by ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO"),". If no ",(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," clause is specified, all variables from the scope will be copied as sub-attributes into the ",(0,r.kt)("em",{parentName:"p"},"groupsVariable"),". "),(0,r.kt)("p",null,"This is safe but can have a negative impact on performance if there are many variables in scope or the variables contain massive amounts of data. "),(0,r.kt)("p",null,"The following example limits the variables that are copied into the ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," to just ",(0,r.kt)("em",{parentName:"p"},"name"),". The variables ",(0,r.kt)("em",{parentName:"p"},"u")," and ",(0,r.kt)("em",{parentName:"p"},"someCalculation")," also present in the scope will not be copied into ",(0,r.kt)("em",{parentName:"p"},"groupsVariable")," because they are not listed in the ",(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," clause:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  LET name = u.name\n  LET someCalculation = u.value1 + u.value2\n  COLLECT city = u.city INTO groups KEEP name \n  RETURN { \n    "city" : city, \n    "userNames" : groups[*].name \n  }\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," is only valid in combination with ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO"),". Only valid variable names can be used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," clause. ",(0,r.kt)("inlineCode",{parentName:"p"},"KEEP")," supports the specification of multiple variable names."),(0,r.kt)("h2",{id:"group-length-calculation"},"Group length calculation"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," also provides a special ",(0,r.kt)("em",{parentName:"p"},"WITH COUNT")," clause that can be used to determine the number of group members efficiently."),(0,r.kt)("p",null,"The simplest form just returns the number of items that made it into the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  COLLECT WITH COUNT INTO length\n  RETURN length\n")),(0,r.kt)("p",null,"The above is equivalent to, but less efficient than:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"RETURN LENGTH(users)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"WITH COUNT")," clause can also be used to efficiently count the number\nof items in each group:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT age = u.age WITH COUNT INTO length\n  RETURN { \n    "age" : age, \n    "count" : length \n  }\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"WITH COUNT")," clause can only be used together with an ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO")," clause.")),(0,r.kt)("h2",{id:"aggregation"},"Aggregation"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement can be used to perform aggregation of data per group. To only determine group lengths, the ",(0,r.kt)("inlineCode",{parentName:"p"},"WITH COUNT INTO")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," can be used as described before."),(0,r.kt)("p",null,"For other aggregations, it is possible to run aggregate functions on the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),"\nresults:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  COLLECT ageGroup = FLOOR(u.age / 5) * 5 INTO g\n  RETURN { \n    "ageGroup" : ageGroup,\n    "minAge" : MIN(g[*].u.age),\n    "maxAge" : MAX(g[*].u.age)\n  }\n')),(0,r.kt)("p",null,"The above however requires storing all group values during the collect operation for all groups, which can be inefficient. "),(0,r.kt)("p",null,"The special ",(0,r.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," allows building the aggregate values incrementally during the collect operation, and is therefore often more efficient."),(0,r.kt)("p",null,"With the ",(0,r.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," variant the above query becomes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  COLLECT ageGroup = FLOOR(u.age / 5) * 5 \n  AGGREGATE minAge = MIN(u.age), maxAge = MAX(u.age)\n  RETURN {\n    ageGroup, \n    minAge, \n    maxAge \n  }\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," keyword can only be used after the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," keyword. If used, it must directly follow the declaration of the grouping keys. If no grouping keys are used, it must follow the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," keyword directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  COLLECT AGGREGATE minAge = MIN(u.age), maxAge = MAX(u.age)\n  RETURN {\n    minAge, \n    maxAge \n  }\n")),(0,r.kt)("p",null,"Only specific expressions are allowed on the right-hand side of each ",(0,r.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," assignment:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"on the top level, an aggregate expression must be a call to one of the supported aggregation functions ",(0,r.kt)("inlineCode",{parentName:"p"},"LENGTH"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MIN"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MAX"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SUM"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AVERAGE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"STDDEV_POPULATION"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"STDDEV_SAMPLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"VARIANCE_POPULATION"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"VARIANCE_SAMPLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UNIQUE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SORTED_UNIQUE")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"COUNT_DISTINCT"),". The following aliases are allowed too: ",(0,r.kt)("inlineCode",{parentName:"p"},"COUNT")," (for ",(0,r.kt)("inlineCode",{parentName:"p"},"LENGTH"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"AVG")," (for ",(0,r.kt)("inlineCode",{parentName:"p"},"AVERAGE"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"STDDEV")," (for ",(0,r.kt)("inlineCode",{parentName:"p"},"STDDEV_POPULATION"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"VARIANCE")," (for ",(0,r.kt)("inlineCode",{parentName:"p"},"VARIANCE_POPULATION"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"COUNT_UNIQUE")," (for ",(0,r.kt)("inlineCode",{parentName:"p"},"COUNT_DISTINCT"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"an aggregate expression must not refer to variables introduced by the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," itself"))),(0,r.kt)("h2",{id:"collect-variants"},"COLLECT variants"),(0,r.kt)("p",null,"There are two variants of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," that the optimizer can choose from: the ",(0,r.kt)("em",{parentName:"p"},"sorted")," variant and the ",(0,r.kt)("em",{parentName:"p"},"hash")," variant. The ",(0,r.kt)("em",{parentName:"p"},"hash")," variant only becomes a candidate for ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statements that do not use an ",(0,r.kt)("inlineCode",{parentName:"p"},"INTO")," clause."),(0,r.kt)("p",null,"The optimizer will always generate a plan that employs the ",(0,r.kt)("em",{parentName:"p"},"sorted")," method. The ",(0,r.kt)("em",{parentName:"p"},"sorted")," method requires its input to be sorted by the group criteria specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," clause. To ensure correctness of the result, the C8QL optimizer will automatically insert a ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement into the query in front of the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement. The optimizer may be able to optimize away that ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement later if a sorted index is present on the group criteria. "),(0,r.kt)("p",null,"In case a ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement qualifies for using the ",(0,r.kt)("em",{parentName:"p"},"hash")," variant, the optimizer will create an extra plan for it at the beginning of the planning phase. In this plan, no extra ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement will be added in front of the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),". This is because the ",(0,r.kt)("em",{parentName:"p"},"hash")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," does not require sorted input. Instead, a ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement will be added after the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," to sort its output. This ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement may be optimized away again in later stages. "),(0,r.kt)("p",null,"If the sort order of the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," is irrelevant to the user, adding the extra instruction ",(0,r.kt)("em",{parentName:"p"},"SORT null")," after the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," will allow the optimizer to remove the sorts altogether:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  COLLECT age = u.age\n  SORT null  /* note: will be optimized away */\n  RETURN age\n")),(0,r.kt)("p",null,"Which ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," variant is used by the optimizer depends on the optimizer's cost estimations. The created plans with the different ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," variants will be shipped through the regular optimization pipeline. In the end, the optimizer will pick the plan with the lowest estimated total cost as usual. "),(0,r.kt)("p",null,"In general, the ",(0,r.kt)("em",{parentName:"p"},"sorted")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," should be preferred in cases when there is a sorted index present on the group criteria. In this case the optimizer can eliminate the ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," statement in front of the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),", so that no ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT")," will be left. "),(0,r.kt)("p",null,"If there is no sorted index available on the group criteria, the up-front sort required by the ",(0,r.kt)("em",{parentName:"p"},"sorted")," variant can be expensive. In this case it is likely that the optimizer will prefer the ",(0,r.kt)("em",{parentName:"p"},"hash")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),", which does not require its input to be sorted. "),(0,r.kt)("p",null,"Which variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," was actually used can be figured out by looking into the execution plan of a query, specifically the ",(0,r.kt)("em",{parentName:"p"},"AggregateNode")," and its ",(0,r.kt)("em",{parentName:"p"},"aggregationOptions")," attribute."),(0,r.kt)("h2",{id:"setting-collect-options"},"Setting COLLECT options"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"options")," can be used in a ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement to inform the optimizer about the preferred ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," method. When specifying the following appendix to a ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement, the optimizer will always use the ",(0,r.kt)("em",{parentName:"p"},"sorted")," variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," and not even create a plan using the ",(0,r.kt)("em",{parentName:"p"},"hash")," variant:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'OPTIONS { method: "sorted" }\n')),(0,r.kt)("p",null,"It is also possible to specify ",(0,r.kt)("em",{parentName:"p"},"hash")," as the preferred method. In this case the optimizer will create a plan using the ",(0,r.kt)("em",{parentName:"p"},"hash")," method only if the COLLECT statement qualifies (not all COLLECT statements can use the ",(0,r.kt)("em",{parentName:"p"},"hash")," method). In case the COLLECT statement qualifies, there will be only a one plan that uses the ",(0,r.kt)("em",{parentName:"p"},"hash")," method. If it does not qualify, the optimizer will use the ",(0,r.kt)("em",{parentName:"p"},"sorted")," method."),(0,r.kt)("p",null,"If no method is specified, then the optimizer will create a plan that uses the ",(0,r.kt)("em",{parentName:"p"},"sorted")," method, and an additional plan using the ",(0,r.kt)("em",{parentName:"p"},"hash")," method if the COLLECT statement qualifies for it."),(0,r.kt)("h2",{id:"collect-vs-return-distinct"},"COLLECT vs. RETURN DISTINCT"),(0,r.kt)("p",null,"In order to make a result set unique, one can either use ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT"),". Behind the scenes, both variants will work by creating an ",(0,r.kt)("em",{parentName:"p"},"AggregateNode"),". For both variants, the optimizer may try the sorted and the hashed variant of ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),". The difference is therefore mainly syntactical, with ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," saving a bit of typing when compared to an equivalent ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  RETURN DISTINCT u.age\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  COLLECT age = u.age\n  RETURN age\n")),(0,r.kt)("p",null,"However, ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," is vastly more flexible than ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT"),". Aside from its sophisticated grouping and aggregation capabilities, ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," also allows you to place a ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," operation before ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURN")," to potentially stop the ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," operation early."),(0,r.kt)("p",null,"Additionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," supports ",(0,r.kt)("a",{parentName:"p",href:"#setting-collect-options"},"options"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," does not change the order of results, whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"COLLECT")," sorts them (regardless of the method, ",(0,r.kt)("em",{parentName:"p"},"sorted")," or ",(0,r.kt)("em",{parentName:"p"},"hash"),") unless explicitly disabled by the user with a subsequent ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT null")," (see ",(0,r.kt)("a",{parentName:"p",href:"#collect-variants"},"COLLECT variants"),")."))}u.isMDXComponent=!0}}]);