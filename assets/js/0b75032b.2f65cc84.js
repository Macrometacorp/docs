"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[17066],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},50112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_position:13,title:"Common Errors"},o=void 0,l={unversionedId:"queryworkers/c8ql/common-errors",id:"queryworkers/c8ql/common-errors",title:"Common Errors",description:"Trailing semicolons in query strings",source:"@site/docs/queryworkers/c8ql/common-errors.md",sourceDirName:"queryworkers/c8ql",slug:"/queryworkers/c8ql/common-errors",permalink:"/docs/queryworkers/c8ql/common-errors",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/common-errors.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Common Errors"},sidebar:"defaultSidebar",previous:{title:"Array Operators",permalink:"/docs/queryworkers/c8ql/array-operators"},next:{title:"C8QL Syntax",permalink:"/docs/queryworkers/c8ql/c8ql-syntax"}},s={},u=[{value:"Trailing semicolons in query strings",id:"trailing-semicolons-in-query-strings",level:2},{value:"String concatenation",id:"string-concatenation",level:2},{value:"Parameter injection vulnerability",id:"parameter-injection-vulnerability",level:2},{value:"Parameter injection examples",id:"parameter-injection-examples",level:3},{value:"Avoiding parameter injection",id:"avoiding-parameter-injection",level:3},{value:"What bind parameters are",id:"what-bind-parameters-are",level:4},{value:"How bind parameters are used",id:"how-bind-parameters-are-used",level:4},{value:"Using bind parameters in dynamic queries",id:"using-bind-parameters-in-dynamic-queries",level:4},{value:"Input value validation and sanitation",id:"input-value-validation-and-sanitation",level:4},{value:"Bind parameter types",id:"bind-parameter-types",level:4},{value:"Unexpected long running queries",id:"unexpected-long-running-queries",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"trailing-semicolons-in-query-strings"},"Trailing semicolons in query strings"),(0,r.kt)("p",null,"Many databases allow sending multiple queries at once. In this case, multiple queries are separated using the semicolon character. Often it is also supported to execute a single query that has a semicolon at its end."),(0,r.kt)("p",null,"C8QL does not support this, and it is a parse error to use a semicolon at the end\nof an C8QL query string."),(0,r.kt)("h2",{id:"string-concatenation"},"String concatenation"),(0,r.kt)("p",null,"In C8QL, strings must be concatenated using the ",(0,r.kt)("a",{parentName:"p",href:"./functions/string#concat"},"CONCAT()")," function. Joining them together with the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator is not supported. Especially as JavaScript programmer it is easy to walk into this trap:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'RETURN "foo" + "bar" // [ 0 ]\nRETURN "foo" + 123   // [ 123 ]\nRETURN "123" + 200   // [ 323 ]\n')),(0,r.kt)("p",null,"The arithmetic plus operator expects numbers as operands, and will try to implicitly cast them to numbers if they are of different type. ",(0,r.kt)("inlineCode",{parentName:"p"},'"foo"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'"bar"')," are casted to ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," and then added to together (still zero). If an actual number is added, that number will be returned (adding zero doesn't change the result). If the string is a valid string representation of a number, then it is casted to a number. Thus, adding ",(0,r.kt)("inlineCode",{parentName:"p"},'"123"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},"200")," results in two numbers being added up to ",(0,r.kt)("inlineCode",{parentName:"p"},"323"),"."),(0,r.kt)("p",null,"To concatenate elements (with implicit casting to string for non-string values), do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'RETURN CONCAT("foo", "bar") // [ "foobar" ]\nRETURN CONCAT("foo", 123)   // [ "foo123" ]\nRETURN CONCAT("123", 200)   // [ "123200" ]\n')),(0,r.kt)("h2",{id:"parameter-injection-vulnerability"},"Parameter injection vulnerability"),(0,r.kt)("p",null,"Parameter injection means that potentially malicious content is inserted into a query which may change its meaning. It is a security issue that may allow an attacker to execute arbitrary queries on the database data."),(0,r.kt)("p",null,"It often occurs if applications trustfully insert user-provided inputs into a query string, and do not fully or incorrectly filter them. It also occurs often when applications build queries naively, without using security mechanisms often provided by database software or querying mechanisms."),(0,r.kt)("p",null,"C8QL is not vulnerable to parameter injection in itself, but queries might be constructed on the client-side or on an application server."),(0,r.kt)("p",null,"Assembling query strings with simple ",(0,r.kt)("strong",{parentName:"p"},"string concatenation")," looks trivial, but is potentially ",(0,r.kt)("strong",{parentName:"p"},"unsafe"),". "),(0,r.kt)("p",null,"You should use ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/bind-parameters"},"bind parameters")," instead whenever possible, use query building functionality if provided by a SDK (see ",(0,r.kt)("a",{parentName:"p",href:"../../sdks"},"SDKs")," for example) or at least sanitize user input with great care."),(0,r.kt)("h3",{id:"parameter-injection-examples"},"Parameter injection examples"),(0,r.kt)("p",null,"Below you find a simple query using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/queryworkers/c8ql/common-errors"},"JavaScript API")," that is fed with some dynamic input value, pretending it coming from a web form. This could be the case in a Foxx service. The route happily picks up the input value, and puts it into a query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// evil!\nvar what = req.params("searchValue");  // user input value from web form\n\n// ...\nvar query = "FOR doc IN collection FILTER doc.value == " + what + " RETURN doc";\ndb._query(query, params).toArray();\n')),(0,r.kt)("p",null,"The above will probably work fine for numeric input values."),(0,r.kt)("p",null,"What could an attacker do to this query? Here are a few suggestions to use for the ",(0,r.kt)("inlineCode",{parentName:"p"},"searchValue")," parameter:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"for returning all documents in the collection:",(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"li"},"1 || true")),(0,r.kt)("li",{parentName:"ul"},"for removing all documents:",(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"li"},"1 || true REMOVE doc IN collection //")),(0,r.kt)("li",{parentName:"ul"},"for inserting new documents:",(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"li"},'1 || true INSERT { foo: "bar" } IN collection //'))),(0,r.kt)("p",null,"It should have become obvious that this is extremely unsafe and should be avoided. A pattern often seen to counteract this is trying to quote and escape potentially unsafe input values before putting them into query strings."),(0,r.kt)("p",null,"This may work in some situations, but it is easy to overlook something or get it subtly wrong:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// We are sanitizing now, but it is still evil!\nvar value = req.params("searchValue").replace(/\'/g, \'\');\n\n// ...\n\nvar query = "FOR doc IN collection FILTER doc.value == \'" + value + "\' RETURN doc";\ndb._query(query, params).toArray();\n')),(0,r.kt)("p",null,"The above example uses single quotes for enclosing the potentially unsafe user input, and also replaces all single quotes in the input value beforehand."),(0,r.kt)("p",null,"Not only may that change the user input (leading to subtle errors such as ",(0,r.kt)("em",{parentName:"p"},'"why does my search for ',(0,r.kt)("inlineCode",{parentName:"em"},"O'Brien"),' not return any results?"'),"), but it is also still unsafe. If the user input contains a backslash at the end (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"foo bar\\"),"), that backslash will escape the closing single quote, allowing the user input to break out of the string fence again."),(0,r.kt)("p",null,"It gets worse if user input is inserted into the query at multiple places. Let us assume we have a query with two dynamic values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'query = "FOR doc IN collection FILTER doc.value == \'" + value +\n        "\' && doc.type == \'" + type + "\' RETURN doc";\n')),(0,r.kt)("p",null,"If an attacker inserted ",(0,r.kt)("inlineCode",{parentName:"p"},"\\")," for parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,r.kt)("inlineCode",{parentName:"p"}," || true REMOVE doc IN collection //")," for parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),", then the effective query would become:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR doc IN collection\n  FILTER doc.value == '\\' && doc.type == ' || true\n  REMOVE doc IN collection //' RETURN doc\n")),(0,r.kt)("p",null,"This is highly undesirable. The backslash escapes the closing single quote, turning the ",(0,r.kt)("inlineCode",{parentName:"p"},"doc.type")," condition into a string, which gets compared to ",(0,r.kt)("inlineCode",{parentName:"p"},"doc.value"),". "),(0,r.kt)("p",null,"Further more, an always true or-condition as well as a remove operation are injected, changing the query purpose entirely. The original return operation gets commented out and the query will truncate the collection instead of returning a few documents."),(0,r.kt)("h3",{id:"avoiding-parameter-injection"},"Avoiding parameter injection"),(0,r.kt)("p",null,"Instead of mixing query string fragments with user inputs naively via string concatenation, use either ",(0,r.kt)("strong",{parentName:"p"},"bind parameters")," or a ",(0,r.kt)("strong",{parentName:"p"},"query builder"),". Both can help to avoid the problem of injection, because they allow separating the actual query operations (like ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"REMOVE"),") from (user input) values."),(0,r.kt)("p",null,"Below, the focus is on bind parameters. This is not to say that query builders shouldn't be used. They were simply omitted here for the sake of simplicity."),(0,r.kt)("h4",{id:"what-bind-parameters-are"},"What bind parameters are"),(0,r.kt)("p",null,"Bind parameters in C8QL queries are special tokens that act as placeholders for actual values. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR doc IN collection\n  FILTER doc.value == @what\n  RETURN doc\n")),(0,r.kt)("p",null,"In the above query, ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," is a bind parameter. In order to execute this query, a value for bind parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," must be specified. Otherwise query execution will fail with error 1551 (",(0,r.kt)("em",{parentName:"p"},"no value specified for declared bind parameter"),"). "),(0,r.kt)("p",null,"If a value for ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," gets specified, the query can be executed. However, the query string and the bind parameter values (i.e. the contents of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," bind parameter) will be handled separately. What's in the bind parameter will always be treated as a value, and it can't get out of its sandbox and change the semantic meaning of a query."),(0,r.kt)("h4",{id:"how-bind-parameters-are-used"},"How bind parameters are used"),(0,r.kt)("p",null,"To execute a query with bind parameters, the query string (containing the bind parameters) and the bind parameter values are specified separately (note that when the bind parameter value is assigned, the prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," needs to be omitted):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// query string with bind parameter\nvar query = "FOR doc IN collection FILTER doc.value == @what RETURN doc";\n\n// actual value for bind parameter\nvar params = { what: 42 };\n\n// run query, specifying query string and bind parameter separately\ndb._query(query, params).toArray();\n')),(0,r.kt)("p",null,"If a malicious user would set ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," to a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1 || true"),", this wouldn't do any harm. C8QL would treat the contents of ",(0,r.kt)("inlineCode",{parentName:"p"},"@what")," as a single string token, and the meaning of the query would remain unchanged. The actually executed query would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'FOR doc IN collection\n  FILTER doc.value == "1 || true"\n  RETURN doc\n')),(0,r.kt)("p",null,"Thanks to bind parameters it is also impossible to turn a selection (i.e. read-only) query into a data deletion query."),(0,r.kt)("h4",{id:"using-bind-parameters-in-dynamic-queries"},"Using bind parameters in dynamic queries"),(0,r.kt)("p",null,"Bind parameters are helpful, so it makes sense to use them for handling the dynamic values. You can even use them for queries that itself are highly dynamic, for example with conditional ",(0,r.kt)("inlineCode",{parentName:"p"},"FILTER")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," parts."),(0,r.kt)("p",null,"Here's how to do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Note: this example has a slight issue... hang on reading\nvar query = "FOR doc IN collection";\nvar params = { };\n\nif (useFilter) {\n  query += " FILTER doc.value == @what";\n  params.what = req.params("searchValue");\n}\n\nif (useLimit) {\n  // not quite right, see below\n  query += " LIMIT @offset, @count";\n  params.offset = req.params("offset");\n  params.count = req.params("count");\n}\n\nquery += " RETURN doc";\ndb._query(query, params).toArray();\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In this example we're back to string concatenation, but without the problem of the query being vulnerable to arbitrary modifications.")),(0,r.kt)("h4",{id:"input-value-validation-and-sanitation"},"Input value validation and sanitation"),(0,r.kt)("p",null,"Still you should prefer to be paranoid, and try to detect invalid input values as early as possible, at least before executing a query with them. This is because some input parameters may affect the runtime behavior of queries negatively or, when modified, may lead to queries throwing runtime errors instead of returning valid results. This isn't something an attacker should deserve."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," is a good example for this: if used with a single argument, the argument should be numeric. When ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," is given a string value, executing the query will fail. You may want to detect this early and don't return an HTTP 500 (as this would signal attackers that they were successful breaking your application)."),(0,r.kt)("p",null,"Another problem with ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," is that high ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," values are likely more expensive than low ones, and you may want to disallow using ",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT")," values exceeding a certain threshold."),(0,r.kt)("p",null,"Here is what you could do in such cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'var query = "FOR doc IN collection LIMIT @count RETURN doc";\n\n// some default value for limit\nvar params = { count: 100 };\n\nif (useLimit) {\n  var count = req.params("count");\n\n  // abort if value does not look like an integer\n  if (! preg_match(/^d+$/, count)) {\n    throw "invalid count value!";\n  }\n\n  // actually turn it into an integer\n  params.count = parseInt(count, 10); // turn into numeric value\n}\n\nif (params.count < 1 || params.count > 1000) {\n  // value is outside of accepted thresholds\n  throw "invalid count value!";\n}\n\ndb._query(query, params).toArray();\n')),(0,r.kt)("p",null,"This is a bit more complex, but that is a price you are likely willing to pay for a bit of extra safety. In reality you may want to use a framework for validation (such as ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/joi"},"joi"),'{:target="_blank"} which comes bundled with GDN) instead of writing your own checks all over the place.'),(0,r.kt)("h4",{id:"bind-parameter-types"},"Bind parameter types"),(0,r.kt)("p",null,"There are two types of bind parameters in C8QL:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bind parameters for ",(0,r.kt)("strong",{parentName:"p"},"values"),":",(0,r.kt)("br",null),"\nThose are prefixed with a single ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," in C8QL queries, and are specified without the prefix when they get their value assigned. These bind parameters can contain any valid JSON value."),(0,r.kt)("p",{parentName:"li"},"Examples: ",(0,r.kt)("inlineCode",{parentName:"p"},"@what"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@searchValue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bind parameters for ",(0,r.kt)("strong",{parentName:"p"},"collections"),":",(0,r.kt)("br",null),"\nThese are prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"@@")," in C8QL queries, and are replaced with the name of a collection. When the bind parameter value is assigned, the parameter itself must be specified with a single ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," prefix. Only string values are allowed for this type of bind parameters."),(0,r.kt)("p",{parentName:"li"},"Examples: ",(0,r.kt)("inlineCode",{parentName:"p"},"@@collection"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@@edgeColl")))),(0,r.kt)("p",null,"The latter type of bind parameter is probably not used as often, and it should not be used together with user input. Otherwise users may freely determine on which collection your C8QL queries will operate on (this might be a valid use case, but normally it is extremely undesired)."),(0,r.kt)("h2",{id:"unexpected-long-running-queries"},"Unexpected long running queries"),(0,r.kt)("p",null,"Slow queries can have various reasons and be legitimate for queries with a high computational complexity or if they touch a lot of data. Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Explain")," feature to inspect execution plans and verify that appropriate indexes are utilized. Also check for mistakes such as references to the wrong variables."),(0,r.kt)("p",null,"A literal collection name, which is not part of constructs like ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UPDATE ... IN")," etc., stands for an array of all documents of that collection and can cause an entire collection to be materialized before further processing. It should thus be avoided."),(0,r.kt)("p",null,"Check the execution plan for ",(0,r.kt)("inlineCode",{parentName:"p"},"/* all collection documents */")," and verify that it is intended. You should also see a warning if you execute such a query:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"collection 'coll' used as expression operand")),(0,r.kt)("p",null,"For example, instead of:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"RETURN coll[* LIMIT 1]\n")),(0,r.kt)("p",null,"with the execution plan ..."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Execution plan:\n Id   NodeType          Est.   Comment\n  1   SingletonNode        1   * ROOT\n  2   CalculationNode      1     - LET #2 = coll   /* all collection documents */[* LIMIT  0, 1]   /* v8 expression */\n  3   ReturnNode           1     - RETURN #2\n")),(0,r.kt)("p",null,"You can use the following equivalent query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"FOR doc IN coll\n    LIMIT 1\n    RETURN doc\n")),(0,r.kt)("p",null,"with the (better) execution plan:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Execution plan:\n Id   NodeType                  Est.   Comment\n  1   SingletonNode                1   * ROOT\n  2   EnumerateCollectionNode     44     - FOR doc IN Characters   /* full collection scan */\n  3   LimitNode                    1       - LIMIT 0, 1\n  4   ReturnNode                   1       - RETURN doc\n")),(0,r.kt)("p",null,"Similarly, make sure you have not confused any variable names with collection names by accident:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET names = ["John", "Mary", ...]\n// supposed to refer to variable "names", not collection "Names"\nFOR name IN Names\n    ...\n')))}c.isMDXComponent=!0}}]);