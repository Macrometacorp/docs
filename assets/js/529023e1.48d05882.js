"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[59850],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=u(a),d=r,y=m["".concat(o,".").concat(d)]||m[d]||c[d]||s;return a?n.createElement(y,i(i({ref:t},p),{},{components:a})):n.createElement(y,i({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var u=2;u<s;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},12570:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const s={title:"Data Types"},i=void 0,l={unversionedId:"queryworkers/c8ql/data-types",id:"queryworkers/c8ql/data-types",title:"Data Types",description:"C8QL supports both primitive and compound data types. The following types are available:",source:"@site/docs/queryworkers/c8ql/data-types.md",sourceDirName:"queryworkers/c8ql",slug:"/queryworkers/c8ql/data-types",permalink:"/docs/queryworkers/c8ql/data-types",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/data-types.md",tags:[],version:"current",frontMatter:{title:"Data Types"},sidebar:"defaultSidebar",previous:{title:"C8QL Syntax",permalink:"/docs/queryworkers/c8ql/c8ql-syntax"},next:{title:"Queries and Null Attributes",permalink:"/docs/queryworkers/c8ql/queries-null-attributes"}},o={},u=[{value:"Primitive types",id:"primitive-types",level:2},{value:"Numeric literals",id:"numeric-literals",level:3},{value:"String literals",id:"string-literals",level:3},{value:"Compound types",id:"compound-types",level:2},{value:"Arrays / Lists",id:"arrays--lists",level:3},{value:"Objects / Documents",id:"objects--documents",level:3}],p={toc:u};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"C8QL supports both primitive and compound data types. The following types are available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Primitive types"),": Consisting of exactly one value"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null"),": An empty value, also, the absence of a value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool"),": Boolean truth value with possible values ",(0,r.kt)("em",{parentName:"li"},"false")," and ",(0,r.kt)("em",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number"),": Signed (real) number"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"string"),": UTF-8 encoded text value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Compound types"),": Consisting of multiple values"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"array"),": Sequence of values, referred to by their positions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"object / document"),": Sequence of values, referred to by their names")))),(0,r.kt)("h2",{id:"primitive-types"},"Primitive types"),(0,r.kt)("p",null,"The following primitive data types are available."),(0,r.kt)("h3",{id:"numeric-literals"},"Numeric literals"),(0,r.kt)("p",null,"Numeric literals can be integers or real values. They can optionally be signed using the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," symbols. The scientific notation is also supported."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"1\n42\n-1\n-42\n1.23\n-99.99\n0.1\n-4.87e103\n")),(0,r.kt)("p",null,"All numeric values are treated as 64-bit double-precision values internally. The internal format used is IEEE 754."),(0,r.kt)("h3",{id:"string-literals"},"String literals"),(0,r.kt)("p",null,"String literals must be enclosed in single or double quotes. If the used quote character is to be used itself within the string literal, it must be escaped using the backslash symbol.  Backslash literals themselves also be escaped using a backslash."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'"yikes!"\n"don\'t know"\n"this is a \\"quoted\\" word"\n"this is a longer string."\n"the path separator on Windows is \\\\"\n\n\'yikes!\'\n\'don\'t know\'\n\'this is a longer string.\'\n\'the path separator on Windows is \\\\\'\n')),(0,r.kt)("p",null,"All string literals must be UTF-8 encoded. It is currently not possible to use arbitrary binary data if it is not UTF-8 encoded. A workaround to use binary data is to encode the data using base64 or other algorithms on the application side before storing, and decoding it on application side after retrieval."),(0,r.kt)("h2",{id:"compound-types"},"Compound types"),(0,r.kt)("p",null,"C8QL supports two compound types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"arrays"),": A composition of unnamed values, each accessible by their positions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"objects / documents"),": A composition of named values, each accessible by their names")),(0,r.kt)("h3",{id:"arrays--lists"},"Arrays / Lists"),(0,r.kt)("p",null,"The first supported compound type is the array type. Arrays are effectively sequences of (unnamed / anonymous) values. Individual array elements can be accessed by their positions. The order of elements in an array is important."),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"array-declaration")," starts with the ",(0,r.kt)("em",{parentName:"p"},"[")," symbol and ends with the ",(0,r.kt)("em",{parentName:"p"},"]")," symbol. An ",(0,r.kt)("em",{parentName:"p"},"array-declaration")," contains zero or many ",(0,r.kt)("em",{parentName:"p"},"expression_s, separated from each other with the "),",_ symbol."),(0,r.kt)("p",null,"In the easiest case, an array is empty and thus looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"[ ]\n")),(0,r.kt)("p",null,"Array elements can be any legal ",(0,r.kt)("em",{parentName:"p"},"expression")," values. Nesting of arrays is supported."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[ 1, 2, 3 ]\n[ -99, "yikes!", [ true, [ "no"], [ ] ], 1 ]\n[ [ "fox", "marshal" ] ]\n')),(0,r.kt)("p",null,"Individual array values can later be accessed by their positions using the ",(0,r.kt)("em",{parentName:"p"},"[]")," accessor. The position of the accessed element must be a numeric value. Positions start at 0. It is also possible to use negative index values to access array values starting from the end of the array. This is convenient if the length of the array is unknown and access to elements at the end of the array is required."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// access 1st array element (elements start at index 0)\nu.friends[0]\n\n// access 3rd array element\nu.friends[2]\n\n// access last array element\nu.friends[-1]\n\n// access second to last array element\nu.friends[-2]\n")),(0,r.kt)("h3",{id:"objects--documents"},"Objects / Documents"),(0,r.kt)("p",null,"The other supported compound type is the object (or document) type. Objects are a composition of zero to many attributes. Each attribute is a name/value pair. Object attributes can be accessed individually by their names."),(0,r.kt)("p",null,"Object declarations start with the ",(0,r.kt)("em",{parentName:"p"},"{")," symbol and end with the ",(0,r.kt)("em",{parentName:"p"},"}")," symbol. An object contains zero to many attribute declarations, separated from each other with the ",(0,r.kt)("em",{parentName:"p"},",")," symbol.  In the simplest case, an object is empty. Its declaration would then be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"{ }\n")),(0,r.kt)("p",null,"Each attribute in an object is a name / value pair. Name and value of an attribute are separated using the ",(0,r.kt)("inlineCode",{parentName:"p"},":")," symbol."),(0,r.kt)("p",null,"The attribute name is mandatory and must be specified as a quoted or unquoted string. If a keyword is used as an attribute name, the attribute name must be quoted:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{ return : 1 }     /* won\'t work */\n{ "return" : 1 }   /* works ! */\n{ `return` : 1 }   /* works, too! */\n')),(0,r.kt)("p",null,"Object attribute names can be computed using dynamic expressions, too. To disambiguate regular attribute names from attribute name expressions, computed attribute names must be enclosed in ",(0,r.kt)("inlineCode",{parentName:"p"},"[and]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{ [ CONCAT("test/", "bar") ] : "someValue" }\n')),(0,r.kt)("p",null,"There is also shorthand notation for attributes which is handy for returning existing variables easily:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET name = "Peter"\nLET age = 42\nRETURN { name, age }\n')),(0,r.kt)("p",null,"The above is the shorthand equivalent for the generic form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET name = "Peter"\nLET age = 42\nRETURN { name : name, age : age }\n')),(0,r.kt)("p",null,"Any valid expression can be used as an attribute value. That also means nested objects can be used as attribute values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ name : "Peter" }\n{ "name" : "Vanessa", "age" : 15 }\n{ "name" : "John", likes : [ "Swimming", "Skiing" ], "address" : { "street" : "Cucumber lane", "zip" : "94242" } }\n')),(0,r.kt)("p",null,"Individual object attributes can later be accessed by their names using the ",(0,r.kt)("inlineCode",{parentName:"p"},".")," accessor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"u.address.city.name\nu.friends[0].name.first\n")),(0,r.kt)("p",null,"Attributes can also be accessed using the ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," accessor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'u["address"]["city"]["name"]\nu["friends"][0]["name"]["first"]\n')),(0,r.kt)("p",null,"In contrast to the dot accessor, the square brackets allow for expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET attr1 = "friends"\nLET attr2 = "name"\nu[attr1][0][attr2][ CONCAT("fir", "st") ]\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If a non-existing attribute is accessed in one or the other way, the result will be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", without error or warning.")))}c.isMDXComponent=!0}}]);