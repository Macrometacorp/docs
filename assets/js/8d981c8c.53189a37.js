"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[96244],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),l=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=l(n),d=r,b=p["".concat(u,".").concat(d)]||p[d]||c[d]||i;return n?a.createElement(b,s(s({ref:t},m),{},{components:n})):a.createElement(b,s({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=p;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},66189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_position:5,title:"Dynamic Attribute Names"},s=void 0,o={unversionedId:"queryworkers/c8ql/examples/dynamic-attribute-names",id:"queryworkers/c8ql/examples/dynamic-attribute-names",title:"Dynamic Attribute Names",description:"You might want a C8QL query to return results with attribute names assembled by a function, or with a variable number of attributes.",source:"@site/docs/queryworkers/c8ql/examples/dynamic-attribute-names.md",sourceDirName:"queryworkers/c8ql/examples",slug:"/queryworkers/c8ql/examples/dynamic-attribute-names",permalink:"/docs/queryworkers/c8ql/examples/dynamic-attribute-names",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/examples/dynamic-attribute-names.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Dynamic Attribute Names"},sidebar:"defaultSidebar",previous:{title:"Diffing Two Documents",permalink:"/docs/queryworkers/c8ql/examples/diffing-documents"},next:{title:"Grouping",permalink:"/docs/queryworkers/c8ql/examples/grouping"}},u={},l=[{value:"Using expressions as attribute names",id:"using-expressions-as-attribute-names",level:2},{value:"Subquery solution",id:"subquery-solution",level:2}],m={toc:l};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"You might want a C8QL query to return results with attribute names assembled by a function, or with a variable number of attributes."),(0,r.kt)("p",null,"This will not work by specifying the result using a regular object literal, as object literals require the names and numbers of attributes to be fixed at query compile time."),(0,r.kt)("p",null,"There are two solutions to getting dynamic attribute names to work:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using expressions as attribute names (fixed amount of attributes)"),(0,r.kt)("li",{parentName:"ul"},"Using subqueries and the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIP()")," function (variable amount of attributes)")),(0,r.kt)("h2",{id:"using-expressions-as-attribute-names"},"Using expressions as attribute names"),(0,r.kt)("p",null,"This solution works in cases where the number of dynamic attributes to return is known in advance, and only the attribute names need to be calculated using an expression."),(0,r.kt)("p",null,"GDN allows using expressions instead of fixed attribute names in object literals. Using expressions as attribute names requires enclosing the expression in extra ",(0,r.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," to disambiguate them from regular, unquoted attribute names."),(0,r.kt)("p",null,"Let us create a result that returns the original document data contained in a dynamically named attribute. We will be using the expression ",(0,r.kt)("inlineCode",{parentName:"p"},"doc.type")," for the attribute name. We will also return some other attributes from the original documents, but prefix them with the documents' ",(0,r.kt)("inlineCode",{parentName:"p"},"_key")," attribute values. For this we also need attribute name expressions."),(0,r.kt)("p",null,"Here is a query showing how to do this. The attribute name expressions all required to be enclosed in ",(0,r.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," in order to make this work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "_key" : "3231748397810", "gender" : "f", "status" : "active", "type" : "user" },\n  { "_key" : "3231754427122", "gender" : "m", "status" : "inactive", "type" : "unknown" }\n]\n\nFOR doc IN documents\n  RETURN {\n    [ doc.type ] : {\n      [ CONCAT(doc._key, "_gender") ] : doc.gender,\n      [ CONCAT(doc._key, "_status") ] : doc.status\n    }\n  }\n')),(0,r.kt)("p",null,"This will return:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user": {\n      "3231748397810_gender": "f",\n      "3231748397810_status": "active"\n    }\n  },\n  {\n    "unknown": {\n      "3231754427122_gender": "m",\n      "3231754427122_status": "inactive"\n    }\n  }\n]\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Attribute name expressions and regular, unquoted attribute names can be mixed.")),(0,r.kt)("h2",{id:"subquery-solution"},"Subquery solution"),(0,r.kt)("p",null,"A generalized solution is to let a subquery or another function produce the dynamic attribute names, and finally pass them through the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIP()")," function to create an object from them."),(0,r.kt)("p",null,"Let us assume we want to process the following input documents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "name": "test", "gender": "f", "status": "active", "type": "user" }\n{ "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n')),(0,r.kt)("p",null,"Let us also assume our goal for each of these documents is to return only the attribute names that contain the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", together with their respective values."),(0,r.kt)("p",null,"To extract the attribute names and values from the original documents, we can use a subquery as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name": "test"," gender": "f", "status": "active", "type": "user" },\n  { "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n]\n\nFOR doc IN documents\n  RETURN (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: name,\n        value: doc[name]\n      }\n  )\n')),(0,r.kt)("p",null,"The subquery will only let attribute names pass that contain the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". The results of the subquery are then made available to the main query and will be returned. But the attribute names in the result are still ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),", so we're not there yet."),(0,r.kt)("p",null,"So let us also employ C8QL's ",(0,r.kt)("a",{parentName:"p",href:"../functions/document#zip"},"ZIP()")," function, which can create an object from two arrays:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the first parameter to ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIP()")," is an array with the attribute names"),(0,r.kt)("li",{parentName:"ul"},"the second parameter to ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIP()")," is an array with the attribute values")),(0,r.kt)("p",null,"Instead of directly returning the subquery result, we first capture it in a variable, and pass the variable's ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," components into ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIP()")," like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name" : "test"," gender" : "f", "status" : "active", "type" : "user" },\n  { "name" : "dummy", "gender" : "m", "status" : "inactive", "type" : "unknown", "magicFlag" : 23 }\n]\n\nFOR doc IN documents\n  LET attributes = (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: name,\n        value: doc[name]\n      }\n  )\n  RETURN ZIP(attributes[*].name, attributes[*].value)\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We have to use the expansion operator (",(0,r.kt)("inlineCode",{parentName:"p"},"[*]"),") on ",(0,r.kt)("inlineCode",{parentName:"p"},"attributes")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"attributes")," itself is an array, and we want either the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," attribute or the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," attribute of each of its members.")),(0,r.kt)("p",null,"To prove this is working, here is the above query's result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "name": "test",\n    "status": "active"\n  },\n  {\n    "name": "dummy",\n    "status": "inactive",\n    "magicFlag": 23\n  }\n]\n')),(0,r.kt)("p",null,"As can be seen, the two results have a different amount of result attributes. We can also make the result a bit more dynamic by prefixing each attribute with the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," attribute:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name": "test"," gender": "f", "status": "active", "type": "user" },\n  { "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n]\n\nFOR doc IN documents\n  LET attributes = (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: CONCAT(doc.name, \'-\', name),\n        value: doc[name]\n      }\n  )\n  RETURN ZIP(attributes[*].name, attributes[*].value)\n')),(0,r.kt)("p",null,"That will give us document-specific attribute names like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "test-name": "test",\n    "test-status": "active"\n  },\n  {\n    "dummy-name": "dummy",\n    "dummy-status": "inactive",\n    "dummy-magicFlag": 23\n  }\n]\n')))}c.isMDXComponent=!0}}]);