"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11093],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),l=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),c=l(a),d=i,h=c["".concat(o,".").concat(d)]||c[d]||u[d]||r;return a?n.createElement(h,s(s({ref:t},m),{},{components:a})):n.createElement(h,s({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=c;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:i,s[1]=p;for(var l=2;l<r;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},67195:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>l});var n=a(87462),i=(a(67294),a(3905));const r={sidebar_position:9},s="Publishing Data",p={unversionedId:"cep/tutorials/publishing-data",id:"cep/tutorials/publishing-data",title:"Publishing Data",description:"When information is processed by the stream processor, the output is presented as events in a streaming manner. This output can be published to databases, files, cloud-based applications or other streaming applications.",source:"@site/docs/cep/tutorials/publishing-data.md",sourceDirName:"cep/tutorials",slug:"/cep/tutorials/publishing-data",permalink:"/docs/cep/tutorials/publishing-data",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/cep/tutorials/publishing-data.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"defaultSidebar",previous:{title:"Correlating Data",permalink:"/docs/cep/tutorials/correlating-data"},next:{title:"Executing Scripts",permalink:"/docs/cep/tutorials/executing-scripts"}},o={},l=[{value:"Publishing data using an event sink",id:"publishing-data-using-an-event-sink",level:2},{value:"Defining event sink in the stream application",id:"defining-event-sink-in-the-stream-application",level:3},{value:"Supported event formats",id:"supported-event-formats",level:2},{value:"Publishing data in default format",id:"publishing-data-in-default-format",level:3},{value:"Publishing data in custom format",id:"publishing-data-in-custom-format",level:3}],m={toc:l};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"publishing-data"},"Publishing Data"),(0,i.kt)("p",null,"When information is processed by the stream processor, the output is presented as events in a streaming manner. This output can be published to databases, files, cloud-based applications or other streaming applications."),(0,i.kt)("p",null,"For the stream processor to publish events, the following is required."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"message schema"),": The messages selected to be published by a streaming integration flow are identified by their\nschemas. This schema is defined via an output stream definition. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"sink"),": The output can be published to different interfaces including streaming applications, cloud-based applications, databases, and files. There are different sink types to support the different interfaces. The output can also be published in a range of formats. In order to select the required interface and format for a specific streaming integration flow, you need to configure a sink in the relevant stream application via the ",(0,i.kt)("inlineCode",{parentName:"p"},"sink.type")," annotation."))),(0,i.kt)("p",null,"A sink configuration consists of three parts."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sink.type"),": This annotation defines the sink type via which the data is published, and allows you to configure the sink parameters (which change depending on the sink type). For the complete list of supported sink types, see ",(0,i.kt)("a",{parentName:"li",href:"/docs/cep/query-guide/stream#sink"},"Stream Query Guide - Sink"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"map.type"),": This annotation specifies the format in which the data is published, and allows you to configure the mapping parameters (which change based of the mapping type/format selected). For the complete list of supported mapping types, see ",(0,i.kt)("a",{parentName:"li",href:"/docs/cep/query-guide/stream#sink-mapper"},"Stream Query Guide - Sink Mapper"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attributes"),": This annotation specifies a custom mapping based on which events in the streaming integration flow that need to be published are identified. This is useful when the attributes of the output messages you want the Streaming Integrator to publish are different to the corresponding attribute name in the stream definition. e.g., In a scenario where the Streaming Integrator is publishing the average temperature per second, the temperature can be referred to as  ",(0,i.kt)("inlineCode",{parentName:"li"},"avgTemp")," in the output stream definition in your Stream application. However, you want to publish it with the ",(0,i.kt)("inlineCode",{parentName:"li"},"Temperature")," to the streaming application to which you are publishing. In this instance, you need a custom mapping to indicate that ",(0,i.kt)("inlineCode",{parentName:"li"},"Temperature")," is the same as ",(0,i.kt)("inlineCode",{parentName:"li"},"avgTemp"),".")),(0,i.kt)("h2",{id:"publishing-data-using-an-event-sink"},"Publishing data using an event sink"),(0,i.kt)("p",null,"This section explains how to configure a basic sink without mapping. "),(0,i.kt)("h3",{id:"defining-event-sink-in-the-stream-application"},"Defining event sink in the stream application"),(0,i.kt)("p",null,"To create a stream application with the sink configuration defined inline, follow the steps below."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Open the GUI and start creating a new Stream application. For more information, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/cep/tutorials/create-stream-app"},"Creating a Stream Application"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Enter a name for the stream application as shown below."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'@App:name("<Stream_Application_Name>)\n')),(0,i.kt)("p",{parentName:"li"},"For example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'@App:name("SalesTotalsApp")\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Define the output stream based on the schema in which you want to publish data. The format is as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE STREAM <Stream_Name> (attribute1_name attribute1_type, attribute2_name attribute2_type, ...);\n")),(0,i.kt)("p",{parentName:"li"},"For example: "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE STREAM PublishSalesTotalsStream (transNo int, product string, price int, quantity int, salesValue long);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Connect a sink to the stream definition you added as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK <Sink_Name> WITH (type='<SINK_TYPE>') (attribute1_name attribute1_type, attribute2_name attribute2_type, ...);\n")),(0,i.kt)("p",{parentName:"li"},"Here, the sink type needs to be selected based on the interface to which you want to publish the output. For more information, see ",(0,i.kt)("a",{parentName:"p",href:"#supported-event-sink-types"},"Supported sink types"),". ",(0,i.kt)("br",null)),(0,i.kt)("p",{parentName:"li"},"Example: If you want to publish the output as messages, you can add a sink with ",(0,i.kt)("inlineCode",{parentName:"p"},"c8streams")," as the type."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK PublishSalesTotalsStream WITH (type='stream', stream.list=\"PublishSalesTotalsStream\") (transNo int, product string, price int, quantity int, salesValue long);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add and configure parameters related to the sink type you selected:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK <Sink_Name> WITH (type='<SINK_TYPE>', <PARAMETER1_NAME>='<PARAMETER1_VALUE>', ...) (attribute1_name attribute1_type, attribute2_name attribute2_type, ...);\n")),(0,i.kt)("p",{parentName:"li"},"e.g., By adding a parameter named ",(0,i.kt)("inlineCode",{parentName:"p"},"prefix")," to the log sink used as an example in the previous step, you can specify a prefix with which you want to see the output logs printed."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK PublishSalesTotalsStream WITH (type='stream', stream.list='Sales Totals') (transNo int, product string, price int, quantity int, salesValue long);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Now let's complete adding the required stream app constructs to receive and process the input data."),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add an input stream with a connected source configuration as shown below."),(0,i.kt)("p",{parentName:"li"},"e.g., Assuming that the schema of the input events are same as that of the output events, and that they are received via C8DB collection, you can add the input stream definition"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SOURCE ConsumeSalesTotalsStream WITH (type='database', collection='SweetProductionEP') (transNo int, product string, price int, quantity int, salesValue long);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add a query to get the received events from the input stream and direct them to the output stream as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into <OUTPUT_STREAM_NAME>\nselect <ATTRIBUTE1_Name>, <ATTRIBUTE2_NAME>, ... \nfrom <INPUT_STREAM_NAME>\ngroup by <ATTRIBUTE_NAME>;\n")),(0,i.kt)("p",{parentName:"li"},"e.g., Assuming that you are publishing the events with the existing values as logs in the output console without any further processing, you can define the query as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into PublishSalesTotalsStream\nselect *\nfrom ConsumeSalesTotalsStream\ngroup by product;\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Save the stream application."))),(0,i.kt)("h2",{id:"supported-event-formats"},"Supported event formats"),(0,i.kt)("h3",{id:"publishing-data-in-default-format"},"Publishing data in default format"),(0,i.kt)("p",null,"Stream processor publishes events in default format when it does not make any changes to the attribute names in the output stream before publishing. To understand how this is done, follow the procedure below:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a stream application with a sink configuration following the instructions in the ",(0,i.kt)("a",{parentName:"p",href:"#defining-event-sink-in-the-stream-application"},"Defining event sink in the Stream application")," section.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add a ",(0,i.kt)("inlineCode",{parentName:"p"},"map.type")," annotation with the mapping type to the sink configuration as shown below."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK <Sink_Name> WITH (type='<SINK_TYPE>', map.type='MAP_TYPE') (attribute1_name attribute1_type, attribute2_name attribute2_type, ...);\n")),(0,i.kt)("p",{parentName:"li"},"The map type specifies the format in which the events are published. e.g., In the example that you used, you can\nspecify the output logs to be printed in the text format by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," as the mapping type."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE SINK PublishSalesTotalsStream WITH (type='stream', stream.list='Sales Totals', map.type=text) (transNo int, product string, price int, quantity int, salesValue long);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Save the stream application. If you save the stream application that was created using the example configurations,\nthe completed stream application is as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"```sql\n@App:name(\"SalesTotalsApp\")\n@App:description(\"Description of the plan\")\n@App:qlVersion(\"2\")\n\nCREATE SOURCE ConsumerSalesTotalsStream WITH (type='database', collection.name='SalesTotalsEP', map.type='json') (transNo int, product string, price int, quantity int, salesValue long);\n\nCREATE SINK PublishSalesTotalsStream WITH (type='stream', stream.list='Sales Totals', map.type=text) (transNo int, product string, price int, quantity int, salesValue long);\n\nselect transNo, product, price, quantity, salesValue\nfrom ConsumerSalesTotalsStream\ngroup by product\ninsert into PublishSalesTotalsStream;\n```\n")))),(0,i.kt)("h3",{id:"publishing-data-in-custom-format"},"Publishing data in custom format"),(0,i.kt)("p",null,"Stream processor publishes data in the custom format when it makes changes to the attribute names in the output stream before publishing. To understand how this is done, follow the procedure below:"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In this section, you can update the same stream application that you saved in the ",(0,i.kt)("a",{parentName:"p",href:"#publishing-a-message-in-default-format"},"Publishing data in default format")," section.")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Open your stream application with a sink configuration.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Within the ",(0,i.kt)("inlineCode",{parentName:"p"},"map.type")," annotation of the sink configuration, add a ",(0,i.kt)("inlineCode",{parentName:"p"},"map.payload")," annotation. There are two ways to configure this:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Some mappers such as ",(0,i.kt)("inlineCode",{parentName:"p"},"xml"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"json"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," accept only one output payload using the following format: "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},'map.payload="<PAYLOAD>"\n')),(0,i.kt)("p",{parentName:"li"},"  e.g., In the example, the mapping type is ",(0,i.kt)("inlineCode",{parentName:"p"},"text"),". Therefore, you can add a message to be printed with the output by configuring the ",(0,i.kt)("inlineCode",{parentName:"p"},"map.payload")," annotation as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},'map.payload="This is a test message from {{user}}."\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Some mappers such as ",(0,i.kt)("inlineCode",{parentName:"p"},"key-value")," accept series of mapping values defined as follows: "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"map.payload=\"key1='mapping_1', 'key2'='user : {{user}}'\"\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Save the stream application."))))}u.isMDXComponent=!0}}]);