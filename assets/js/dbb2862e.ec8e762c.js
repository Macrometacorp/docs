"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[28220],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var o=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=o.createContext({}),c=function(e){var n=o.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(i.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=s,y=d["".concat(i,".").concat(m)]||d[m]||u[m]||a;return t?o.createElement(y,r(r({ref:n},p),{},{components:t})):o.createElement(y,r({ref:n},p))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,r=new Array(a);r[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:s,r[1]=l;for(var c=2;c<a;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>r});var o=t(67294),s=t(34334);const a="tabItem_Ymn6";function r(e){let{children:n,hidden:t,className:r}=e;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(a,r),hidden:t},n)}},65488:(e,n,t)=>{t.d(n,{Z:()=>m});var o=t(87462),s=t(67294),a=t(34334),r=t(72389),l=t(67392),i=t(7094),c=t(12466);const p="tabList__CuJ",u="tabItem_LNqP";function d(e){const{lazy:n,block:t,defaultValue:r,values:d,groupId:m,className:y}=e,h=s.Children.map(e.children,(e=>{if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),_=d??h.map((e=>{let{props:{value:n,label:t,attributes:o}}=e;return{value:n,label:t,attributes:o}})),f=(0,l.l)(_,((e,n)=>e.value===n.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===r?r:r??h.find((e=>e.props.default))?.props.value??h[0].props.value;if(null!==g&&!_.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${_.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:b,setTabGroupChoices:T}=(0,i.U)(),[R,N]=(0,s.useState)(g),E=[],{blockElementScrollPositionUntilNextRender:A}=(0,c.o5)();if(null!=m){const e=b[m];null!=e&&e!==R&&_.some((n=>n.value===e))&&N(e)}const w=e=>{const n=e.currentTarget,t=E.indexOf(n),o=_[t].value;o!==R&&(A(n),N(o),null!=m&&T(m,String(o)))},k=e=>{let n=null;switch(e.key){case"ArrowRight":{const t=E.indexOf(e.currentTarget)+1;n=E[t]??E[0];break}case"ArrowLeft":{const t=E.indexOf(e.currentTarget)-1;n=E[t]??E[E.length-1];break}}n?.focus()};return s.createElement("div",{className:(0,a.Z)("tabs-container",p)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},y)},_.map((e=>{let{value:n,label:t,attributes:r}=e;return s.createElement("li",(0,o.Z)({role:"tab",tabIndex:R===n?0:-1,"aria-selected":R===n,key:n,ref:e=>E.push(e),onKeyDown:k,onFocus:w,onClick:w},r,{className:(0,a.Z)("tabs__item",u,r?.className,{"tabs__item--active":R===n})}),t??n)}))),n?(0,s.cloneElement)(h.filter((e=>e.props.value===R))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},h.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==R})))))}function m(e){const n=(0,r.Z)();return s.createElement(d,(0,o.Z)({key:String(n)},e))}},48458:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>u});var o=t(87462),s=(t(67294),t(3905)),a=t(65488),r=t(85162);const l={sidebar_position:7,title:"Using Rest APIs"},i=void 0,c={unversionedId:"collections/documents/tutorials/using_rest_api",id:"collections/documents/tutorials/using_rest_api",title:"Using Rest APIs",description:"Modern applications need to be highly responsive, always online, and able to access data instantly across the globe. At the same time, they need to be deployed on datacenters close to their users. Macrometa global data network (GDN) is a real-time materialized view engine that provides instant data to applications and APIs in a simple interface.",source:"@site/docs/collections/documents/tutorials/using_rest_api.md",sourceDirName:"collections/documents/tutorials",slug:"/collections/documents/tutorials/using_rest_api",permalink:"/docs/collections/documents/tutorials/using_rest_api",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/collections/documents/tutorials/using_rest_api.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Using Rest APIs"},sidebar:"defaultSidebar",previous:{title:"Spot Collections",permalink:"/docs/collections/documents/tutorials/using-spotcollections"},next:{title:"GeoSpatial",permalink:"/docs/collections/documents/geospatial/"}},p={},u=[{value:"Prerequisites:",id:"prerequisites",level:2},{value:"API Browser",id:"api-browser",level:2},{value:"Working with Documents",id:"working-with-documents",level:2},{value:"Tutorial",id:"tutorial",level:3},{value:"Query using C8QL",id:"query-using-c8ql",level:2},{value:"Tutorial",id:"tutorial-1",level:3},{value:"Publish-Subscribe with Streams",id:"publish-subscribe-with-streams",level:2},{value:"Tutorial",id:"tutorial-2",level:3},{value:"Query as API (RestQL)",id:"query-as-api-restql",level:2},{value:"Tutorial",id:"tutorial-3",level:3},{value:"Working with Graphs",id:"working-with-graphs",level:2},{value:"Tutorial",id:"tutorial-4",level:3},{value:"Stream Processing",id:"stream-processing",level:2}],d={toc:u};function m(e){let{components:n,...l}=e;return(0,s.kt)("wrapper",(0,o.Z)({},d,l,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modern applications need to be highly responsive, always online, and able to access data instantly across the globe. At the same time, they need to be deployed on datacenters close to their users. Macrometa global data network (GDN) is a real-time materialized view engine that provides instant data to applications and APIs in a simple interface."),(0,s.kt)("h2",{id:"prerequisites"},"Prerequisites:"),(0,s.kt)("p",null,"A Macrometa GDN tenant account and credentials."),(0,s.kt)("h2",{id:"api-browser"},"API Browser"),(0,s.kt)("p",null,"Your main tool for using REST APIs is the API reference in the ",(0,s.kt)("a",{parentName:"p",href:"https://play.paas.macrometa.io"},"GDN")," web browser interface. Use the built-in API reference to run various calls and view their input and output."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"GDN API Browser",src:t(25369).Z,width:"1059",height:"807"})),(0,s.kt)("h2",{id:"working-with-documents"},"Working with Documents"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"document")," is a JSON-serializable dictionary object with the following properties:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_key")," identifies a document within a collection."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_id")," identifies a document across all collections in a fabric with the following format: ",(0,s.kt)("inlineCode",{parentName:"li"},"{collection name}/{document key}"),". This is also known as a ",(0,s.kt)("em",{parentName:"li"},"handle"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_rev")," indicates the latest revision of a document. GDN supports MVCC (Multiple Version Concurrency Control) and stores each document in multiple revisions. This field is automatically populated, but you can use it to validate a document against its current revision.")),(0,s.kt)("p",null,"For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n"_id": "students/bruce",\n"_key": "bruce",\n"_rev": "_Wm3dzEi--_",\n"first_name": "Bruce",\n"last_name": "Wayne",\n"address": {\n  "street": "1007 Mountain Dr.",\n  "city": "Gotham",\n  "state": "NJ"\n},\n"is_rich": True,\n"friends": ["robin", "gordon"]\n}\n')),(0,s.kt)("h3",{id:"tutorial"},"Tutorial"),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"}," import json\nimport requests\n\n# Set constants\nURL = \"api-play.paas.macrometa.io\"\nHTTP_URL = f\"https://{URL}\"\nCOLLECTION_NAME = 'testcollection'\nEMAIL = \"nemo@nautilus.com\"\nPASSWORD = \"xxxxx\"\nAUTH_TOKEN = \"bearer \"\nFABRIC = \"_system\"\nURL = f\"{HTTP_URL}/_open/auth\"\npayload = {\n    'email': EMAIL,\n    'password': PASSWORD,\n\n}\nheaders = {\n    'content-type': 'application/json'\n}\n\nresponse = requests.post(URL, data=json.dumps(payload), headers=headers)\n\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body[\"jwt\"]\n    TENANT = resp_body[\"tenant\"]\nelse:\n    raise Exception(f\"Error while getting auth token. \"\n                    f\"Code:{response.status_code}, Reason:{response.reason}\")\n\nsession = requests.session()\nsession.headers.update({\"content-type\": 'application/json'})\nsession.headers.update({\"authorization\": AUTH_TOKEN})\n\n# Get list of all regions\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/datacenter/all\"\ndcl_resp = session.get(URL)\ndcl_list = json.loads(dcl_resp.text)\nregions = []\nfor dcl in dcl_list:\n    dcl_url = dcl['tags']['url']\n    regions.append(dcl_url)\nprint(\"\\nList of regions: \", regions)\n\n# Create a document collection\n# Note: Create a test collection. Set \"type\" to 2 for documents or 3 for edges\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/collection\"\npayload = {\n    \"name\": COLLECTION_NAME,\n    \"type\": 2\n}\nresp = session.post(URL, data=json.dumps(payload))\nresp = json.loads(resp.text)\nif 'error' in resp and resp['error']:\n    print(\"ERROR: \" + resp[\"errorMessage\"])\nelse:\n    print(\"\\nCollection created: \", resp['name'])\n\n# Insert a document into a collection\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}\"\npayload = {'GPA': 3.5, 'first': 'Lola', 'last': 'Martin', '_key': 'Lola'}\nresp = session.post(URL, data=json.dumps(payload))\nprint(\"\\nDocument inserted: \", resp.text)\n\n# Data can either be a single document or a list of documents\n# Insert multiple documents\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}\"\ndata = [\n    {'GPA': 3.2, 'first': 'Abby', 'last': 'Page', '_key': 'Abby'},\n    {'GPA': 3.6, 'first': 'John', 'last': 'Kim', '_key': 'John'},\n    {'GPA': 4.0, 'first': 'Emma', 'last': 'Park', '_key': 'Emma'}\n]\nresp = session.post(URL, data=json.dumps(data))\nprint(\"\\nMultiple documents inserted: \", resp.text)\n\n# Read a document with its ID\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}\" + \"/Lola\"\nresp = session.get(URL)\nprint(\"\\nDocument with ID Lola is: \", resp.text)\n\n# Read multiple documents\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/simple/lookup-by-keys\"\npayload = {\"collection\": COLLECTION_NAME,\n           \"keys\": [\"Abby\", \"John\", \"Emma\"]}\nresp = session.put(URL, data=json.dumps(payload))\nresp = json.loads(resp.text)\nprint(\"\\nDocuments: \", resp[\"documents\"])\n\n# Update a single document with its ID\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}/John\"\npayload = {'GPA': 3.6, 'first': 'John', 'last': 'Andrews', '_key': 'John'}\nresp = session.patch(URL, data=json.dumps(payload))\nprint(\"\\nUpdated document with ID John: \", resp.text)\n\n# Update  documents\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}\"\npayload = [\n    {'GPA': 4.6, 'first': 'Lola', 'last': 'Martin', '_key': 'Lola'},\n    {'GPA': 3.2, 'first': 'Abby', 'last': 'Stutguard', '_key': 'Abby'}\n]\nresp = session.patch(URL, data=json.dumps(payload))\nprint(\"\\nUpdated documents: \", resp.text)\n\n# Remove single document with its ID\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}/John\"\nresp = session.delete(URL)\nprint(\"\\nDeleted document with ID John: \", resp.text)\n\n# Remove a multiple document\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME}\"\npayload = [\n    {'GPA': 4.6, 'first': 'Lola', 'last': 'Martin', '_key': 'Lola'},\n    {'GPA': 3.2, 'first': 'Abby', 'last': 'Stutguard', '_key': 'Abby'},\n    {'GPA': 4.0, 'first': 'Emma', 'last': 'Park', '_key': 'Emma'}\n]\nresp = session.delete(URL, data=json.dumps(payload))\nprint(\"\\nDeleted Documents: \", resp.text)\n"))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'class APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor (url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationUrl = "https://api-play.paas.macrometa.io";\n\nconst collectionName = "api_tutorial_documents";\n\nconst run = async function () {\n  const connection = new APIRequest(federationUrl);\n\n  /* -------------------- Log in (nemo@nautilus.com/xxxxxx) -------------------- */\n\n  await connection\n    .login(email, password)\n    .then(() => console.log("\\n1. User authentication done!"))\n    .catch((error) => error);\n\n  /* -------------------------- Create document collection ------------------------- */\n\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: collectionName },\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("2. Collection created successfully", collection)\n    )\n    .catch((error) => console.log(error));\n\n  /* ---------------------------- Insert documents ---------------------------- */\n\n  const document = await connection\n    .req(`/_fabric/_system/_api/document/${collectionName}`, {\n      body: { new: true },\n      method: "POST"\n    })\n    .then((document) => {\n      console.log("3. Document created successfully", document);\n      return document;\n    })\n    .catch((error) => error);\n\n  /* ----------------------------- Read documents ----------------------------- */\n\n  await connection\n    .req(`/_fabric/_system/_api/document/${document._id}`)\n    .then((readDocument) =>\n      console.log("4. Document read successfully", readDocument)\n    )\n    .catch((error) => console.log(error));\n\n  /* ---------------------------- Update documents ---------------------------- */\n\n  await connection\n    .req(`/_fabric/_system/_api/document/${document._id}`, {\n      method: "PATCH",\n      body: { new: false }\n    })\n    .then((updateDocument) =>\n      console.log("5. Document was updated successfully", updateDocument)\n    )\n    .catch((error) => console.log(error));\n\n  /* ----------------------------- Read documents ----------------------------- */\n\n  await connection\n    .req(`/_fabric/_system/_api/document/${document._id}`)\n    .then((updatedReadDocument) =>\n      console.log("6. Document read successfully", updatedReadDocument)\n    )\n    .catch((error) => console.log(error));\n\n  /* ------------------------------- Delete documents ------------------------------ */\n  await connection\n    .req(`/_fabric/_system/_api/document/${document._id}`, {\n      method: "DELETE"\n    })\n    .then((deletedDocument) =>\n      console.log("7. Document with Id " + document._id + " deleted successfully", deletedDocument)\n    )\n    .catch((error) => console.log(error));\n\n  /* --------------------------- Delete collection --------------------------- */\n  await connection\n    .req(`/_fabric/_system/_api/collection/${collectionName}`, {\n      method: "DELETE"\n    })\n    .then((deletedCollection) =>\n      console.log("8. Collection deleted successfully", deletedCollection)\n    )\n    .catch((error) => console.log(error));\n};\n\nrun()\n  .then()\n  .catch((error) => console.log(error));\n')))),(0,s.kt)("h2",{id:"query-using-c8ql"},"Query using C8QL"),(0,s.kt)("p",null,"You can use C8QL to run CRUD Operations."),(0,s.kt)("h3",{id:"tutorial-1"},"Tutorial"),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},'#Using C8QL\nimport json\nimport requests\n\n# Constants\nURL = "api-play.paas.macrometa.io"\nHTTP_URL = f"https://{URL}"\nEMAIL = "nemo@nautilus.com"\nPASSWORD = "xxxxx"\nAUTH_TOKEN = "bearer "\n\n\n# Create HTTPS session\nurl = f"{HTTP_URL}/_open/auth"\npayload = {\n    \'email\': EMAIL,\n    \'password\': PASSWORD\n}\nheaders = {\n    \'content-type\': \'application/json\'\n}\n\nresponse = requests.post(url, data=json.dumps(payload), headers=headers)\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body["jwt"]\n    TENANT = resp_body["tenant"]\nelse:\n    raise Exception(f"Error while getting auth token. "\n                    f"Code:{response.status_code}, Reason:{response.reason}")\n\nsession = requests.session()\nsession.headers.update({"content-type": \'application/json\'})\nsession.headers.update({"authorization": AUTH_TOKEN})\nurl = f"{HTTP_URL}/_fabric/_system/_api/cursor"\n\n\n# Insert documents to the collection\nresp = session.post(url, json={\n    "query": "INSERT{\'name\' : \'Julie\', \'company\' : \'ABC\', \'_key\' : \'Julie\'}" \\\n             "INTO testcollection"\n})\n\n# Read from the collection\nresp = session.post(url, json={\n    "query": "FOR doc IN testcollection RETURN doc"\n})\nprint(resp.text)\n\n# Update documents in the collection\nresp = session.post(url, json={\n    "query": "FOR c IN testcollection UPDATE c WITH{\'company\':\'XYZ\'} IN testcollection"\n})\nprint(resp.text)\n# Upsert documents in the collection\nresp = session.post(url, json={\n    "query": "UPSERT {name: \'John\'} INSERT "\n             "{_key:\'John\', name: \'John\', logins:1, updatedAt: DATE_NOW()}"\n             " UPDATE {\'logins\': OLD.logins + 1, updatedAt: DATE_NOW()} IN testcollection"\n})\nprint(resp.text)\n# Delete documents in the collection\nresp = session.post(url, json={\n    "query": "FOR c IN testcollection REMOVE c IN testcollection"\n})\nprint(resp.text)\n\n'))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'class APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor (url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationUrl = "https://api-play.paas.macrometa.io";\n\nconst insertQuery = {\n  query:\n    "INSERT{\'name\' : \'Julie\', \'company\' : \'ABC\', \'_key\' : \'Julie\'} INTO testcollection"\n};\nconst readQuery = {\n  query: "FOR doc IN testcollection RETURN doc"\n};\nconst updateQuery = {\n  query:\n    "FOR c IN testcollection UPDATE c WITH{\'company\':\'XYZ\'} IN testcollection"\n};\nconst upsertQuery = {\n  query:\n    "UPSERT {name: \'John\'} INSERT {_key:\'John\', name: \'John\', logins:1, updatedAt: DATE_NOW()} UPDATE {\'logins\': OLD.logins + 1, updatedAt: DATE_NOW()} IN testcollection"\n};\n\nconst deleteDocumentsQuery = {\n  query: "FOR c IN testcollection REMOVE c IN testcollection"\n};\nconst collectionName = "testcollection";\n\nconst connection = new APIRequest(federationUrl);\n\nasync function runningQueryFromCursor (query) {\n  await connection\n    .req("/_fabric/_system/_api/cursor", {\n      body: query,\n      method: "POST"\n    })\n    .then((document) => {\n      console.log("Cursor result:", document);\n      return document;\n    })\n    .catch((error) => console.log(error));\n}\n\nasync function deleteCollection (collection) {\n  await connection\n    .req(`/_fabric/_system/_api/collection/${collection}`, {\n      method: "DELETE"\n    })\n    .then((document) => {\n      console.log("9. Delete collection " + collection);\n      return document;\n    })\n    .catch((error) => console.log(error));\n}\n\nasync function createCollection (collection) {\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: collection },\n      method: "POST"\n    })\n    .then((collection) => console.log("2. Collection created: ", collection))\n    .catch((error) => console.log(error));\n}\n\nconst run = async function () {\n  /* -------------------- Log in (nemo@nautilus.com/xxxxxx) -------------------- */\n\n  await connection\n    .login(email, password)\n    .then(() => console.log("\\n1. User authentication done!"))\n    .catch((error) => error);\n\n  /* -------------------------- Create document collection ------------------------- */\n  \n  await createCollection(collectionName);\n\n  /* ---------------------------- Insert documents ---------------------------- */\n  \n  console.log("3. Inserting data in collection " + collectionName);\n  await runningQueryFromCursor(insertQuery);\n\n  /* ---------------------------- Read documents ---------------------------- */\n  \n  console.log("4. Reading data from collection " + collectionName);\n  await runningQueryFromCursor(readQuery);\n\n  /* ---------------------------- Update documents ---------------------------- */\n  \n  console.log("5. Update data from collection " + collectionName);\n  await runningQueryFromCursor(updateQuery);\n\n  /* ---------------------------- Upsert documents ---------------------------- */\n  \n  console.log("6. Upsert data from collection " + collectionName);\n  await runningQueryFromCursor(upsertQuery);\n\n  /* ---------------------------- Read documents ---------------------------- */\n  \n  console.log("7. Reading data from collection " + collectionName);\n  await runningQueryFromCursor(readQuery);\n\n  /* ---------------------------- Delete documents --------------------------- */\n  \n  console.log("8. Delete data from collection " + collectionName);\n  await runningQueryFromCursor(deleteDocumentsQuery);\n\n  /* ---------------------------- Delete collection ---------------------------- */\n  await deleteCollection(collectionName);\n};\n\nrun()\n  .then()\n  .catch((error) => console.log(error));\n')))),(0,s.kt)("h2",{id:"publish-subscribe-with-streams"},"Publish-Subscribe with Streams"),(0,s.kt)("p",null,"GDN streams are a high-performance solution for server-to-server messaging. Streams are built on the ",(0,s.kt)("em",{parentName:"p"},"publish-subscribe")," (pub-sub) pattern in which producers publish messages to streams, and consumers can subscribe to those streams, process incoming messages, and send an acknowledgment to the producer when finished."),(0,s.kt)("p",null,"Streams provide:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Seamless geo-replication of messages across regions."),(0,s.kt)("li",{parentName:"ul"},"Low publish and end-to-end latency."),(0,s.kt)("li",{parentName:"ul"},"Seamless scalability to over a million topics."),(0,s.kt)("li",{parentName:"ul"},"Multiple subscription modes (",(0,s.kt)("inlineCode",{parentName:"li"},"exclusive"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"shared"),", and ",(0,s.kt)("inlineCode",{parentName:"li"},"failover"),") for streams."),(0,s.kt)("li",{parentName:"ul"},"Guaranteed message delivery with persistent message storage.")),(0,s.kt)("h3",{id:"tutorial-2"},"Tutorial"),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},'import json\nimport base64\nimport requests\nfrom websocket import create_connection\nimport six\n\n# Constants\nURL = "api-play.paas.macrometa.io"\nHTTP_URL = f"https://{URL}"\nEMAIL = "nemo@nautilus.com"\nPASSWORD = "xxxxx"\nFABRIC = "_system"\nSTREAM_NAME = "teststream"\nAUTH_TOKEN = "bearer "\nTENANT_NAME = ""\nCONSUMER_NAME = "testconsumer"\nSTREAM_TYPE = "c8global"\n\n# Create HTTPS session with auth endpoint\nurl = f"{HTTP_URL}/_open/auth"\npayload = {\n    \'email\': EMAIL,\n    \'password\': PASSWORD\n}\nheaders = {\n    \'content-type\': \'application/json\'\n}\nresponse = requests.post(url, data=json.dumps(payload), headers=headers)\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body["jwt"]\n    TENANT = resp_body["tenant"]\nelse:\n    raise Exception(f"Error while getting auth token. "\n                    f"Code:{response.status_code}, Reason:{response.reason}")\n\nsession = requests.session()\nsession.headers.update({"content-type": \'application/json\'})\nsession.headers.update({"authorization": AUTH_TOKEN})\n\n# Create a stream\n# Set global=true for a global stream or global=false for a local stream\nurl = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streams/{STREAM_NAME}?global=true"\nresp = session.post(url)\nprint("\\nStream created: ", resp.text)\n\n# Publish messages, Send message in body\nurl = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streams/{STREAM_TYPE}s.{STREAM_NAME}/publish?global=true"\nresp = session.post(url, data="Message")\nprint("\\nStream received message: ", resp.text)\n\n# or using web sockets\nPRODUCER_URL = f"wss://{URL}/_ws/ws/v2/producer/persistent/{TENANT_NAME}/{STREAM_TYPE}.{FABRIC}/{STREAM_TYPE}s.{STREAM_NAME}"\nws = create_connection(PRODUCER_URL, header=[f"authorization: {AUTH_TOKEN}"])\n\npayload = {\n    "payload": base64.b64encode(\n        six.b("Hello World")\n    ).decode("utf-8")\n}\nws.send(json.dumps(payload))\nresponse = json.loads(ws.recv())\n\nif response[\'result\'] == \'ok\':\n    print(\'Message published successfully\')\nelse:\n    print(\'Failed to publish message:\', response)\nws.close()\n\n# Subscribe\nCONSUMER_URL = f"wss://{URL}/_ws/ws/v2/producer/persistent/{TENANT_NAME}/{STREAM_TYPE}.{FABRIC}/{STREAM_TYPE}s.{STREAM_NAME}/{CONSUMER_NAME}"\nws = create_connection(CONSUMER_URL, header=[f"authorization: {AUTH_TOKEN}"])\nwhile True:\n    msg = json.loads(ws.recv())\n    if msg:\n        print(f"received: {base64.b64decode(msg[\'payload\'])}")\n        # Acknowledge successful processing\n        ws.send(json.dumps({\'messageId\': msg[\'messageId\']}))\n        break\nws.close()\n\n# Delete Subscription (unsubscribe)\nurl = f"{HTTP_URL}/_api/streams/subscription/{CONSUMER_NAME}"\nresp = session.delete(url)\nprint("Subscription deleted: ", resp.text)\n'))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const WebSocket = require("ws");\nclass APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor (url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\n\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationName = "api-play.paas.macrometa.io";\nconst federationUrl = `https://${federationName}`;\n\nconst stream = "api_tutorial_streams";\nconst consumerName = "api_tutorial_streams_consumer";\nconst isGlobal = true;\n\nconst run = async function () {\n  const connection = new APIRequest(federationUrl);\n\n  /* -------------------- Log in (nemo@nautilus.com/xxxxxxx) -------------------- */\n\n  const { tenant } = await connection\n    .login(email, password)\n    .then((tenant) => {\n      console.log("\\n1. User authentication done!");\n      return tenant;\n    })\n    .catch((error) => console.log(error));\n\n  /* ------------------------------ Create stream ----------------------------- */\n\n  try {\n    await connection.req(\n      `/_fabric/_system/streams/${stream}?global=${isGlobal}`,\n      {\n        body: { name: stream },\n        method: "POST"\n      }\n    );\n    console.log("2. Stream created successfully");\n  } catch (e) {\n    if (e.status === 409) {\n      console.log("2. Stream already exists, skipping creation of stream");\n    } else {\n      console.log("2. Error while creating stream");\n      throw e;\n    }\n  }\n  console.log("3. Initiation producer and consumer")\n  /* ----------------- Publish and subscribe message to stream ---------------- */\n\n  const region = isGlobal ? "c8global" : "c8local";\n  const streamName = `${region}s.${stream}`;\n\n  // Fetch local URL in case the stream is local\n  const localDcDetails = await connection\n    .req(`/datacenter/local`, {\n      method: "GET"\n    })\n    .catch((error) => console.log(error));\n\n  const dcUrl = localDcDetails.tags.url;\n\n  const url = isGlobal ? federationName : `api-${dcUrl}`;\n\n  const otpConsumer = await connection\n    .req(`/apid/otp`, {\n      method: "POST"\n    })\n    .catch((error) => console.log(error));\n  const otpProducer = await connection\n    .req(`/apid/otp`, {\n      method: "POST"\n    })\n    .catch((error) => console.log(error));\n\n  const consumerUrl = `wss://${url}/_ws/ws/v2/consumer/persistent/${tenant}/${region}._system/${streamName}/${consumerName}?otp=${otpConsumer.otp}`;\n\n  const producerUrl = `wss://${url}/_ws/ws/v2/producer/persistent/${tenant}/${region}._system/${streamName}?otp=${otpProducer.otp}`;\n\n  let consumer;\n  let producer;\n  let producerInterval;\n\n  /* -------------------------- Initalize consumer -------------------------- */\n\n  const initConsumer = () => {\n    return new Promise((resolve) => {\n      consumer = new WebSocket(consumerUrl);\n\n      consumer.onopen = function () {\n        console.log("WebSocket:Consumer is open now for " + streamName);\n        resolve();\n      };\n\n      consumer.onerror = function () {\n        console.log(\n          "Failed to establish WebSocket:Consumer connection for " + streamName\n        );\n      };\n\n      consumer.onclose = function () {\n        console.log("Closed WebSocket:Consumer connection for " + streamName);\n      };\n\n      consumer.onmessage = function (message) {\n        const receivedMsg = message.data && JSON.parse(message.data);\n\n        console.log(\n          `WebSocket:Consumer message received at ${new Date()}`,\n          receivedMsg\n        );\n        console.log(\n          "Payload: ",\n          Buffer.from(receivedMsg.payload, "base64").toString("ascii"),\n          " At: ",\n          receivedMsg.publishTime\n        );\n\n        const ackMsg = { messageId: receivedMsg.messageId };\n        consumer.send(JSON.stringify(ackMsg));\n      };\n    });\n  };\n\n  /* -------------------------- Initalize producer -------------------------- */\n\n  const initProducer = () => {\n    producer = new WebSocket(producerUrl);\n\n    producer.onopen = function () {\n      console.log("WebSocket:Producer is open now for " + streamName);\n      producerInterval = setInterval(function () {\n        console.log(`WebSocket:Producer message sent at ${new Date()}`);\n        producer.send(\n          JSON.stringify({\n            payload: Buffer.from("Hello World").toString("base64")\n          })\n        );\n      }, 10000);\n    };\n\n    producer.onclose = function (e) {\n      console.log("Closed WebSocket:Producer connection for " + streamName);\n      clearInterval(producerInterval);\n    };\n\n    producer.onerror = function (e) {\n      console.log(\n        "Failed to establish WebSocket:Producer connection for " + streamName\n      );\n    };\n  };\n\n  initConsumer()\n    .then(() => {\n      initProducer();\n    })\n    .catch((error) => console.log(error));\n\n  await new Promise((resolve) => setTimeout(resolve, 1 * 40 * 1000));\n\n  consumer.close();\n  console.log("4. Closing consumer...");\n  producer.close();\n  console.log("5. Closing producer...");\n\n  await new Promise((resolve) => setTimeout(resolve, 5000));\n\n  /* ------------------------ Unsubscribe from stream ------------------------ */\n\n  const consumerUnsubscribe = await connection\n    .req(`/_fabric/_system/_api/streams/subscription/${consumerName}`, {\n      method: "DELETE"\n    })\n    .catch((error) => console.log(error));\n\n  console.log(`6. ${consumerName} unsubscribed successfully`, consumerUnsubscribe);\n\n};\n\nrun()\n  .then()\n  .catch((error) => console.log(error));\n')))),(0,s.kt)("h2",{id:"query-as-api-restql"},"Query as API (RestQL)"),(0,s.kt)("p",null,"Globally distributed applications need a fast data platform that can transparently replicate data anywhere in the world, enabling users to access applications on the closest copy of their data. Additionally, these applications need both geo-replicated and local streams to handle pub-sub, ETL, and real-time updates. "),(0,s.kt)("p",null,"Macrometa GDN provides turnkey global distribution and transparent multi-master replication. You can run globally distributed, low-latency workloads with GDN."),(0,s.kt)("h3",{id:"tutorial-3"},"Tutorial"),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},'# Using RESTQL\nimport json\nimport time\n\nimport requests\n\n# Set constants\nURL = "api-play.paas.macrometa.io"\nHTTP_URL = f"https://{URL}"\nEMAIL = "nemo@nautilus.com"\nPASSWORD = "xxxxx"\nFABRIC = "_system"\nAUTH_TOKEN = "bearer "\nREAD_QUERY = "FOR doc IN @@collection RETURN doc"\nQUERY_NAME = "read"\nCOLLECTION_NAME = "api_query_tutorial"\nQUERY_PARAMS = {"@collection": f"{COLLECTION_NAME}"}\nINSERT_QUERY = "FOR i IN 1..100 INSERT { result: i } INTO @@collection"\nUPDATE_QUERY = "FOR doc IN @@collection FILTER doc.result >= 35 " \\\n               "UPDATE doc._key WITH { qualified :true } IN @@collection"\nDELETE_QUERY = "FOR c IN @@collection REMOVE c IN @@collection"\nUPDATE_READ_QUERY = "FOR doc IN @@collection FILTER doc.result < 10 RETURN doc"\n\n# Create HTTPS session\n\nURL = f"{HTTP_URL}/_open/auth"\npayload = {\n    \'email\': EMAIL,\n    \'password\': PASSWORD\n}\nheaders = {\n    \'content-type\': \'application/json\'\n}\n\nresponse = requests.post(URL, data=json.dumps(payload), headers=headers)\n\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body["jwt"]\n    TENANT = resp_body["tenant"]\nelse:\n    raise Exception(f"Error while getting auth token. Code:"\n                    f"{response.status_code}, Reason:{response.reason}")\n\nsession = requests.session()\nsession.headers.update({"content-type": \'application/json\'})\nsession.headers.update({"authorization": AUTH_TOKEN})\n\n# Create a document collection\n# Note: Create a test collection. Set "type" to 2 for documents or 3 for edges\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/collection"\npayload = {\n    "name": COLLECTION_NAME,\n    "type": 2\n}\nresp = session.post(URL, data=json.dumps(payload))\nresp = json.loads(resp.text)\nif \'error\' in resp and resp[\'error\']:\n    print("ERROR: " + resp["errorMessage"])\nelse:\n    print("\\nCollection created: ", resp[\'name\'])\n\n# Create RESTQL\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql"\n\n# Save read query\npayload = {\n    "query": {\n        "name": QUERY_NAME,\n        "parameter": QUERY_PARAMS,\n        "value": READ_QUERY\n    }\n}\n\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nRead query saved: ", resp.text)\ntime.sleep(1)\n# Save insert query\npayload = {\n    "query": {\n        "name": "insert",\n        "value": INSERT_QUERY,\n        "parameter": QUERY_PARAMS,\n\n    }\n}\n\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nInsert query saved: ", resp.text)\ntime.sleep(1)\n# Save update query\npayload = {\n    "query": {\n        "name": "update",\n        "value": UPDATE_QUERY,\n        "parameter": QUERY_PARAMS,\n\n    }\n}\n\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nUpdate query saved: ", resp.text)\ntime.sleep(1)\n# Save delete query\npayload = {\n    "query": {\n        "name": "delete",\n        "value": DELETE_QUERY,\n        "parameter": QUERY_PARAMS,\n\n    }\n}\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nDelete query saved: ", resp.text)\ntime.sleep(1)\n# Execute insert query\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/execute/insert"\npayload = {\n    "bindVars": QUERY_PARAMS,\n}\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nInsert query executed: ", resp.text)\ntime.sleep(1)\n# Execute read query\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/execute/" + QUERY_NAME\npayload = {\n    "bindVars": QUERY_PARAMS,\n}\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nRead query executed: ", resp.text)\ntime.sleep(1)\n# Execute update query\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/execute/update"\npayload = {\n    "bindVars": QUERY_PARAMS,\n}\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nUpdate query executed: ", resp.text)\ntime.sleep(1)\n# Update saved query\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/" + QUERY_NAME\npayload = {\n    "query": {\n        "parameter": QUERY_PARAMS,\n        "value": UPDATE_READ_QUERY\n    }\n}\nresp = session.put(URL, data=json.dumps(payload))\nprint("Query updated: ", resp.text)\ntime.sleep(1)\n# Execute delete query\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/execute/delete"\npayload = {\n    "bindVars": QUERY_PARAMS,\n}\nresp = session.post(URL, data=json.dumps(payload))\nprint("\\nDelete query executed: ", resp.text)\ntime.sleep(1)\n# Delete saved queries\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/{QUERY_NAME}"\nresp = session.delete(URL)\nprint("Read query deleted: ", resp.text)\ntime.sleep(1)\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/insert"\nresp = session.delete(URL)\nprint("Insert query deleted: ", resp.text)\ntime.sleep(1)\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/update"\nresp = session.delete(URL)\nprint("Update query deleted: ", resp.text)\ntime.sleep(1)\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/restql/delete"\nresp = session.delete(URL)\nprint("Delete query deleted: ", resp.text)\n'))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'class APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor(url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\n\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationUrl = "https://api-play.paas.macrometa.io";\nconst collectionName = "api_query_tutorial";\n\nconst readQueryName = "read";\nconst queryParams = { "@collection": collectionName };\nconst readQuery = "FOR doc IN @@collection RETURN doc";\n\nconst insertQueryName = "insert";\nconst insertQuery = "FOR i IN 1..10 INSERT { result: i } INTO @@collection";\n\nconst updateQueryName = "update";\nconst updateQuery =\n  "FOR doc IN @@collection FILTER doc.result >= 3 UPDATE doc._key WITH { qualified :true } IN @@collection";\n\nconst deleteQueryName = "delete";\nconst deleteQuery = "FOR c IN @@collection REMOVE c IN @@collection";\n\nconst readQueryUpdated =\n  "FOR doc IN @@collection FILTER doc.result < 1 RETURN doc";\n\nconst connection = new APIRequest(federationUrl);\n\nasync function saveQueryWorker (queryName, queryValue, queryParams) {\n  await connection\n    .req("/_fabric/_system/_api/restql", {\n      body: {\n        query: {\n          name: queryName,\n          value: queryValue,\n          parameter: queryParams\n        }\n      },\n      method: "POST"\n    })\n    .then((query) =>\n      console.log(`${queryName} query saved successfully `, query)\n    )\n    .catch((error) => console.log(error));\n}\n\nasync function runQueryWorker (queryWorkerName, params) {\n  await connection\n    .req(`/_fabric/_system/_api/restql/execute/${queryWorkerName}`, {\n      body: {\n        bindVars: params\n      },\n      method: "POST"\n    })\n    .then((query) =>\n      console.log(`${queryWorkerName} query worker results: `, query)\n    )\n    .catch((error) => console.log(error));\n}\n\nasync function updateSavedQueryWorker (queryName, newQuery, queryParams) {\n  await connection\n    .req(`/_fabric/_system/_api/restql/${queryName}`, {\n      body: {\n        query: {\n          value: newQuery,\n          parameter: queryParams\n        }\n      },\n      method: "PUT"\n    })\n    .then((updatedQuery) =>\n      console.log(`${queryName} was modified successfully`, updatedQuery)\n    )\n    .catch((error) => console.log(error));\n}\n\nasync function deleteQueryWorker (queryName) {\n  await connection\n    .req(`/_fabric/_system/_api/restql/${queryName}`, {\n      method: "DELETE"\n    })\n    .then((query) => console.log("Query deleted successfully", query))\n    .catch((error) => console.log(error));\n}\n\nasync function createCollection (collection) {\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: collection },\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("2. Collection saved successfully", collection)\n    )\n    .catch((error) => console.log(error));\n}\n\nasync function deleteCollection (collection) {\n  await connection\n    .req(`/_fabric/_system/_api/collection/${collection}`, {\n      method: "DELETE"\n    })\n    .then((collection) =>\n      console.log("Collection deleted successfully", collection)\n    )\n    .catch((error) => console.log(error));\n}\n\nconst run = async function () {\n  try {\n    /* -------------------- Log in (nemo@nautilus.com/xxxxxx) -------------------- */\n\n    await connection\n      .login(email, password)\n      .then(() => console.log("\\n1. User authentication done!"))\n      .catch((error) => console.log(error));\n\n    /* ------------------------ Create collection ----------------------- */\n    await createCollection(collectionName);\n\n    console.log("3. Saving query workers");\n\n    /* ------------------------ Save query worker  ----------------------- */\n    await saveQueryWorker(readQueryName, readQuery, queryParams);\n\n    /* -------------------  Insert query worker ------------------- */\n    await saveQueryWorker(insertQueryName, insertQuery, queryParams);\n\n    /* -------------------  Update query worker ------------------- */\n    await saveQueryWorker(updateQueryName, updateQuery, queryParams);\n\n    /* -------------------  Delete query worker ------------------- */\n    await saveQueryWorker(deleteQueryName, deleteQuery, queryParams);\n\n    await new Promise(r => setTimeout(r, 2000));\n    console.log("4. Running query workers");\n\n    /* ----------------------- Run insert query worker ---------------------- */\n    await runQueryWorker(insertQueryName, queryParams);\n\n    /* ----------------------- Run read query worker ---------------------- */\n    await runQueryWorker(readQueryName, queryParams);\n\n    /* ----------------------- Run update query worker ---------------------- */\n    await runQueryWorker(updateQueryName, queryParams);\n\n    /* ----------------------- Run read query worker ---------------------- */\n    await runQueryWorker(readQueryName, queryParams);\n\n    /* ----------------------- Run delete query worker ---------------------- */\n    await runQueryWorker(deleteQueryName, queryParams);\n\n    /* ----------------------- Update saved query worker ---------------------- */\n    await updateSavedQueryWorker(readQueryName, readQueryUpdated, queryParams);\n\n\n    /* ----------------------------- Delete query workers ----------------------------- */\n    console.log("5. Deleting query workers");\n    await deleteQueryWorker(readQueryName);\n    await deleteQueryWorker(updateQueryName);\n    await deleteQueryWorker(insertQueryName);\n    await deleteQueryWorker(deleteQueryName);\n\n    console.log(`6. Deleting ${collectionName} collection`);\n    await deleteCollection(collectionName);\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nrun();\n')))),(0,s.kt)("h2",{id:"working-with-graphs"},"Working with Graphs"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Graphs")," enable you to do the following:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Structure your data models to make them consistent with your domain."),(0,s.kt)("li",{parentName:"ul"},"Group your data models into logical collections and query them.")),(0,s.kt)("p",null,"A graph consists of ",(0,s.kt)("em",{parentName:"p"},"vertices")," and ",(0,s.kt)("em",{parentName:"p"},"edges")," that are all stored as documents in collections. You can store vertices in document collections or edge collections, enabling you to use an edge as a vertex. Edges can only be stored in edge collections. An ",(0,s.kt)("em",{parentName:"p"},"edge collection")," is similar to a relation table that stores many-to-many relationships between two data tables, and a ",(0,s.kt)("em",{parentName:"p"},"vertex collection")," is like one of the data tables with connected objects. A graph can use one or more ",(0,s.kt)("em",{parentName:"p"},"edge definitions")," to determine which collections are used."),(0,s.kt)("p",null,"An edge collection contains ",(0,s.kt)("em",{parentName:"p"},"edge documents")," and shares its namespace with all other collection types. You can manage edge documents with REST API wrappers for regular documents, but edge collection API wrappers provide the following benefits:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Perform modifications as transactions."),(0,s.kt)("li",{parentName:"ul"},"When inserting edge documents, check them against edge definitions.")),(0,s.kt)("p",null,"Edge documents have two additional required fields:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_from")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"_to"))),(0,s.kt)("p",null,"Edges use these fields to point from one document to another stored in vertex collections. The values of ",(0,s.kt)("inlineCode",{parentName:"p"},"_from")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"_to")," must match the IDs of vertex documents linked by the edge document. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n"_id": "friends/001",\n"_key": "001",\n"_rev": "_Wm3dyle--_",\n"_from": "students/john",  // This value must match the ID of the "from" document.\n"_to": "students/jane",  // This value must match the ID of the "to" document.\n"closeness": 9.5\n}\n')),(0,s.kt)("p",null,"In queries, you can define permissions for the direction of edge relations. For example:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"OUTBOUND: ",(0,s.kt)("inlineCode",{parentName:"li"},"_from")," \u2192 ",(0,s.kt)("inlineCode",{parentName:"li"},"_to")),(0,s.kt)("li",{parentName:"ul"},"INBOUND: ",(0,s.kt)("inlineCode",{parentName:"li"},"_from")," \u2190 ",(0,s.kt)("inlineCode",{parentName:"li"},"_to")),(0,s.kt)("li",{parentName:"ul"},"ANY: ",(0,s.kt)("inlineCode",{parentName:"li"},"_from")," \u2194 ",(0,s.kt)("inlineCode",{parentName:"li"},"_to"))),(0,s.kt)("p",null,"While simple graph queries with a fixed number of hops via the relation table may be doable in SQL with several nested joins, graph databases can handle an arbitrary number of these hops over edge collections - this is called ",(0,s.kt)("inlineCode",{parentName:"p"},"traversal"),". Also edges in one edge collection may point to several vertex collections. It is common to have attributes attached to edges, i.e. a label naming this interconnection."),(0,s.kt)("h3",{id:"tutorial-4"},"Tutorial"),(0,s.kt)("p",null,"To create ",(0,s.kt)("inlineCode",{parentName:"p"},"edge collection")," use same endpoint ",(0,s.kt)("inlineCode",{parentName:"p"},"/_fabric/{fabric_name}/_api/collection")," and pass ",(0,s.kt)("inlineCode",{parentName:"p"},"type:3")," in payload."),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},"import json\nimport requests\n\n# Constants\n\nURL = \"api-play.paas.macrometa.io\"\nHTTP_URL = f\"https://{URL}\"\nEMAIL = \"nemo@nautilus.com\"\nPASSWORD = \"xxxxx\"\nFABRIC = \"_system\"\nAUTH_TOKEN = \"bearer \"\nTENANT_NAME = \"\"\nCOLLECTION_NAME_1 = \"teachers\"\nCOLLECTION_NAME_2 = \"lectures\"\nEDGE_COLL_NAME = \"teach\"\nGRAPH_NAME = \"lectureteacher\"\n\n# Create HTTPS session\n\nURL = f\"{HTTP_URL}/_open/auth\"\npayload = {\n    'email': EMAIL,\n    'password': PASSWORD\n}\nheaders = {\n    'content-type': 'application/json'\n}\n\nresponse = requests.post(URL, data=json.dumps(payload), headers=headers)\n\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body[\"jwt\"]\n    TENANT = resp_body[\"tenant\"]\nelse:\n    raise Exception(f\"Error while getting auth token. \"\n                    f\"Code:{response.status_code}, Reason:{response.reason}\")\n\nsession = requests.session()\nsession.headers.update({\"content-type\": 'application/json'})\nsession.headers.update({\"authorization\": AUTH_TOKEN})\n\n# Create document collections and insert data\n\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/collection\"\npayload = {'name': COLLECTION_NAME_1}\n\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nDocument collection 1 created: \", result)\n\npayload = {'name': COLLECTION_NAME_2}\n\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nDocument collection 2 created: \", result)\n\npayload = [\n    {\n        '_key': 'Jean',\n        'firstname': 'Jean',\n        'lastname': 'Picard',\n        'email': 'jean.picard@macrometa.io'\n    },\n    {\n        '_key': 'James',\n        'firstname': 'James',\n        'lastname': 'Kirk',\n        'email': 'james.kirk@macrometa.io'\n    },\n    {\n        '_key': 'Han',\n        'firstname': 'Han',\n        'lastname': 'Solo',\n        'email': 'han.solo@macrometa.io'\n    },\n    {\n        '_key': 'Bruce',\n        'firstname': 'Bruce',\n        'lastname': 'Wayne',\n        'email': 'bruce.wayne@macrometa.io'\n    }\n]\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME_1}\"\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nDocuments inserted: \", result)\n\npayload = [\n    {'_id': 'lectures/CSC101', 'difficulty': 'easy', '_key': 'CSC101', 'firstname': 'Jean'},\n    {'_id': 'lectures/CSC102', 'difficulty': 'hard', '_key': 'CSC102', 'firstname': 'Jean'},\n    {'_id': 'lectures/CSC103', 'difficulty': 'hard', '_key': 'CSC103', 'firstname': 'Jean'},\n    {'_id': 'lectures/CSC104', 'difficulty': 'moderate', '_key': 'CSC104', 'firstname': 'Jean'}\n\n]\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{COLLECTION_NAME_2}\"\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nDocuments inserted: \", result)\n\n# Create edge collection\npayload = {'name': EDGE_COLL_NAME, \"type\": 3}\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/collection\"\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nEdge collection created: \", result)\npayload = [\n    {\n        '_key': 'Jean-CSC101',\n        '_from': 'teachers/Jean',\n        '_to': 'lectures/CSC101',\n        'online': False\n    },\n    {\n        '_key': 'Jean-CSC102',\n        '_from': 'teachers/Jean',\n        '_to': 'lectures/CSC102',\n        'online': True\n    },\n    {\n        '_key': 'Jean-CSC103',\n        '_from': 'teachers/Jean',\n        '_to': 'lectures/CSC103',\n        'online': False\n    },\n    {\n        '_key': 'Bruce-CSC101',\n        '_from': 'teachers/Bruce',\n        '_to': 'lectures/CSC101',\n        'online': True\n    }\n\n]\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/document/{EDGE_COLL_NAME}\"\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nDocuments inserted: \", result)\n\n# Create a graph\npayload = {\n    \"edgeDefinitions\": [\n        {\n            \"collection\": EDGE_COLL_NAME,\n            \"from\": [\n                \"teachers\"\n            ],\n            \"to\": [\n                \"lectures\"\n            ]\n        }\n    ],\n    \"name\": GRAPH_NAME,\n    \"options\": {}\n}\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/graph\"\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint(\"\\nGraph created: \", result)\n\n# Graph traversal\n# To use outbound traversal, set direction to `out`.\n# To use inbound traversal, set direction to `in`.\nparams = {\n    \"vertex\": \"teachers/Jean\",\n    \"direction\": \"out\"\n}\n\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/edges/{EDGE_COLL_NAME}\"\n\nresp = session.get(URL, params=params)\nresult = json.loads(resp.text)\nprint(\"\\nGraph traversal: \", result)\n\n# Delete graph and collections\n# To delete the graph and save the collections, set dropCollection to `false`.\nparams = {\"dropCollections\": True}\nURL = f\"{HTTP_URL}/_fabric/{FABRIC}/_api/graph/{GRAPH_NAME}\"\nresp = session.delete(URL, params=params)\nresult = json.loads(resp.text)\nprint(\"Graph and collections deleted: \", result)\n"))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'class APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor (url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationUrl = "https://api-play.paas.macrometa.io";\nconst teacherCollection = "teachers";\nconst lecturesCollection = "lectures";\nconst teachEdge = "teach";\nconst lectureTracherGraph = "lectureteacher";\n\nconst teachersPayload = [\n  {\n    _key: "Jean",\n    firstname: "Jean",\n    lastname: "Picard",\n    email: "jean.picard@macrometa.io"\n  },\n  {\n    _key: "James",\n    firstname: "James",\n    lastname: "Kirk",\n    email: "james.kirk@macrometa.io"\n  },\n  {\n    _key: "Han",\n    firstname: "Han",\n    lastname: "Solo",\n    email: "han.solo@macrometa.io"\n  },\n  {\n    _key: "Bruce",\n    firstname: "Bruce",\n    lastname: "Wayne",\n    email: "bruce.wayne@macrometa.io"\n  }\n];\n\nconst lecturesPayload = [\n  {\n    _id: "lectures/CSC101",\n    difficulty: "easy",\n    _key: "CSC101",\n    firstname: "Jean"\n  },\n  {\n    _id: "lectures/CSC102",\n    difficulty: "hard",\n    _key: "CSC102",\n    firstname: "Jean"\n  },\n  {\n    _id: "lectures/CSC103",\n    difficulty: "hard",\n    _key: "CSC103",\n    firstname: "Jean"\n  },\n  {\n    _id: "lectures/CSC104",\n    difficulty: "moderate",\n    _key: "CSC104",\n    firstname: "Jean"\n  }\n];\n\nconst edgePayload = [\n  {\n    _key: "Jean-CSC101",\n    _from: "teachers/Jean",\n    _to: "lectures/CSC101",\n    online: false\n  },\n  {\n    _key: "Jean-CSC102",\n    _from: "teachers/Jean",\n    _to: "lectures/CSC102",\n    online: true\n  },\n  {\n    _key: "Jean-CSC103",\n    _from: "teachers/Jean",\n    _to: "lectures/CSC103",\n    online: false\n  },\n  {\n    _key: "Bruce-CSC101",\n    _from: "teachers/Bruce",\n    _to: "lectures/CSC101",\n    online: true\n  }\n];\n\nconst graphPayload = {\n  edgeDefinitions: [\n    {\n      collection: teachEdge,\n      from: ["teachers"],\n      to: ["lectures"]\n    }\n  ],\n  name: lectureTracherGraph,\n  options: {}\n};\n\nconst tranversalGraphParams = {\n  vertex: "teachers/Jean",\n  direction: "out"\n};\n\nconst run = async function () {\n  const connection = new APIRequest(federationUrl);\n\n  /* -------------------- Log in (nemo@nautilus.com/xxxxxx) -------------------- */\n\n  await connection\n    .login(email, password)\n    .then(() => console.log("\\n1. User authentication done!"))\n    .catch((error) => error);\n\n  /* -------------------- Create teachers collection -------------------- */\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: teacherCollection },\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("2. Collection " + teacherCollection + " created", collection)\n    )\n    .catch((error) => console.log(error));\n\n  /* -------------------- Create lectures collection -------------------- */\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: lecturesCollection },\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log(\n        "3. Collection " + lecturesCollection + " created",\n        collection\n      )\n    )\n    .catch((error) => console.log(error));\n\n   /* -------------------- Load data to teachers collection -------------------- */\n  await connection\n    .req(`/_fabric/_system/_api/document/${teacherCollection}`, {\n      body: teachersPayload,\n      method: "POST"\n    })\n    .then((collection) => console.log("4. Documents inserted", collection))\n    .catch((error) => console.log(error));\n\n   /* -------------------- Load data to lectures collection -------------------- */\n  await connection\n    .req(`/_fabric/_system/_api/document/${lecturesCollection}`, {\n      body: lecturesPayload,\n      method: "POST"\n    })\n    .then((collection) => console.log("5. Documents inserted", collection))\n    .catch((error) => console.log(error));\n\n  /* -------------------- Create edge collection -------------------- */\n  await connection\n    .req("/_fabric/_system/_api/collection", {\n      body: { name: teachEdge, type: 3 },\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("6. Edge collection created successfully", collection)\n    )\n    .catch((error) => console.log(error));\n\n  /* -------------------- Load data to edge collection -------------------- */\n  await connection\n    .req(`/_fabric/_system/_api/document/${teachEdge}`, {\n      body: edgePayload,\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("7. Documents inserted in edge collection", collection)\n    )\n    .catch((error) => console.log(error));\n\n  /* -------------------- Create graph -------------------- */\n  await connection\n    .req("/_fabric/_system/_api/graph", {\n      body: graphPayload,\n      method: "POST"\n    })\n    .then((collection) =>\n      console.log("8. Graph created successfully", collection)\n    )\n    .catch((error) => console.log(error));\n\n  /* -------------------- Load data graph traversal-------------------- */\n  await connection\n    .req(\n      `/_fabric/_system/_api/edges/${teachEdge}?` +\n        new URLSearchParams(tranversalGraphParams),\n      {\n        method: "GET"\n      }\n    )\n    .then((collection) => console.log("9. Graph traversal", collection))\n    .catch((error) => console.log(error));\n\n  /* -------------------- Delete graph and drop collections -------------------- */\n  \n  await connection\n    .req(\n      `/_fabric/_system/_api/graph/${lectureTracherGraph}?` +\n        new URLSearchParams({ dropCollections: true }),\n      {\n        method: "DELETE"\n      }\n    )\n    .then((collection) => console.log("10. Graph deleted", collection))\n    .catch((error) => console.log(error));\n};\n\nrun()\n  .then()\n  .catch((error) => console.log(error));\n\n')))),(0,s.kt)("h2",{id:"stream-processing"},"Stream Processing"),(0,s.kt)("p",null,"Macrometa Stream processing enables you to integrate streaming data into your tenant and enables you to automatically respond to events. A stream processing engine must collect and analyze data generated by business activities, then integrate or act on the data."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Collect: Capture or receive data from various data sources.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Analyze: Analyze data to identify interesting patterns and extract information.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Act: Take actions based on processing results. For example, you can execute code, call an external service, or trigger a complex integration.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Integrate: Make processed data globally available for consumers in the correct format with low latency."))),(0,s.kt)(a.Z,{groupId:"operating-systems",mdxType:"Tabs"},(0,s.kt)(r.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},'import json\nimport time\nimport base64\nimport requests\nfrom websocket import create_connection\nimport six\n\n# Set constants\n\nURL = "api-play.paas.macrometa.io"\nHTTP_URL = f"https://{URL}"\nEMAIL = "nemo@nautilus.com"\nPASSWORD = "xxxxx"\nFABRIC = "_system"\nAUTH_TOKEN = "bearer "\nTENANT_NAME = ""\nSTREAM_NAME = "tutorialAppInputStream"\nSTREAM_APP_NAME = "stream_app_tutorial"\nSTREAM_APP = \'\'\'\n      @App:name(\'stream_app_tutorial\')\n      @App:qlVersion("2")\n      CREATE FUNCTION concatFn[javascript] return string {\n          var str1 = data[0];\n          var str2 = data[1];\n          var str3 = data[2];\n          var response = str1 + str2 + str3;\n          return response;\n      };\n      -- Stream\n      CREATE SOURCE STREAM tutorialAppInputStream (deviceID string, roomNo int, temperature double);\n      -- Table\n      CREATE TABLE tutorialAppOutputTable (id string, temperature double);\n      @info(name=\'Query\')\n      INSERT INTO tutorialAppOutputTable\n      SELECT concatFn(roomNo,\'-\',deviceID) as id, temperature\n      FROM tutorialAppInputStream;\n \'\'\'\nINPUT_DATA = [\n    {\n        "deviceID": "AD11",\n        "roomNo": 200,\n        "temperature": 18,\n    },\n    {"deviceID": "AD11",\n     "roomNo": 201,\n     "temperature": 47},\n]\nSELECT_QUERY = "FOR doc IN tutorialAppOutputTable return doc"\n\n# Create HTTPS session\n\nURL = f"{HTTP_URL}/_open/auth"\npayload = {\n    \'email\': EMAIL,\n    \'password\': PASSWORD\n}\nheaders = {\n    \'content-type\': \'application/json\'\n}\n\nresponse = requests.post(URL, data=json.dumps(payload), headers=headers)\n\nif response.status_code == 200:\n    resp_body = json.loads(response.text)\n    AUTH_TOKEN += resp_body["jwt"]\n    TENANT = resp_body["tenant"]\nelse:\n    raise Exception(f"Error while getting auth token. "\n                    f"Code:{response.status_code}, Reason:{response.reason}")\n\nsession = requests.session()\nsession.headers.update({"content-type": \'application/json\'})\nsession.headers.update({"authorization": AUTH_TOKEN})\n\n# Create stream application\n\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streamapps"\npayload = {\n    "definition": STREAM_APP,\n    "regions": ["devsuccess2-us-east", "devsuccess2-us-central", "devsuccess2-ap-west"]\n\n}\n\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint("\\nStream application created: ", result)\n\n# Activate stream application\n\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streamapps/{STREAM_APP_NAME}/active?active=true"\nresp = session.patch(URL)\nresult = json.loads(resp.text)\nprint("\\nStream application activated: ", result)\n\n# Wait for all inputs and outputs to initialize\ntime.sleep(20)\n\n# Publish messages to the input stream\nSTREAM_TYPE = "c8local"\nPRODUCER_URL = f"wss://{URL}/_ws/ws/v2/producer/persistent/{TENANT_NAME}/{STREAM_TYPE}.{FABRIC}/{STREAM_TYPE}s.{STREAM_NAME}"\n\nws = create_connection(PRODUCER_URL, header=[f"Authorization:{AUTH_TOKEN}"])\npayload = {\n    "payload": base64.b64encode(\n        six.b(json.dumps(INPUT_DATA[0]))\n    ).decode("utf-8")\n}\nws.send(json.dumps(payload))\nresponse = json.loads(ws.recv())\nif response[\'result\'] == \'ok\':\n    print(\'Message published successfully\')\nelse:\n    print(\'Failed to publish message:\', response)\n\npayload = {\n    "payload": base64.b64encode(\n        six.b(json.dumps(INPUT_DATA[1]))\n    ).decode("utf-8")\n}\nws.send(json.dumps(payload))\nresponse = json.loads(ws.recv())\nif response[\'result\'] == \'ok\':\n    print(\'Message published successfully\')\nelse:\n    print(\'Failed to publish message:\', response)\n\nws.close()\n\n# Verify results from the collection\n\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/cursor"\npayload = {\n    "id": "tutorialStreamAppQuery",\n    "query": SELECT_QUERY,\n    "bindVars": {},\n}\nresp = session.post(URL, data=json.dumps(payload))\nresult = json.loads(resp.text)\nprint("\\nStream application results: ", result)\n\n# Delete stream application\n\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streamapps/{STREAM_APP_NAME}"\nresp = session.delete(URL)\nresult = json.loads(resp.text)\nprint("\\nStream application deleted: ", result)\n\n# Delete stream\n\nURL = f"{HTTP_URL}/_fabric/{FABRIC}/_api/streams/{STREAM_TYPE}s.{STREAM_NAME}"\nresp = session.delete(URL)\nresult = json.loads(resp.text)\nprint("\\nStream deleted: ", result)\n'))),(0,s.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},' const WebSocket = require("ws");\nclass APIRequest {\n  _headers = {\n    Accept: "application/json",\n    "Content-Type": "application/json"\n  };\n\n  constructor(url) {\n    this._url = url;\n  }\n\n  login (email, password) {\n    const endpoint = "/_open/auth";\n\n    const self = this;\n\n    return new Promise(function (resolve, reject) {\n      self\n        .req(endpoint, {\n          body: { email, password },\n          method: "POST"\n        })\n        .then(({ jwt, ...data }) => {\n          self._headers.authorization = `bearer ${jwt}`;\n          resolve(data);\n        })\n        .catch(reject);\n    });\n  }\n\n  _handleResponse (response, resolve, reject) {\n    if (response.ok) {\n      resolve(response.json());\n    } else {\n      reject(response);\n    }\n  }\n\n  req (endpoint, { body, ...options } = {}) {\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fetch(self._url + endpoint, {\n        headers: self._headers,\n        body: body ? JSON.stringify(body) : undefined,\n        ...options\n      }).then((response) => self._handleResponse(response, resolve, reject));\n    });\n  }\n}\nconst email = "nemo@nautilus.com";\nconst password = "xxxxxx";\nconst federationName = "api-play.paas.macrometa.io";\nconst federationUrl = `https://${federationName}`;\n\nconst isGlobal = false;\nconst stream = `tutorialAppInputStream`;\nconst streamAppName = `stream_app_tutorial`;\nconst streamApp = `@App:name(\'stream_app_tutorial\')\n  @App:description(\'This application demonstrates how to use user-defined functions in a stream app\')\n\n  define function concatFn[javascript] return string {\n      var str1 = data[0];\n      var str2 = data[1];\n      var str3 = data[2];\n      var response = str1 + str2 + str3;\n      return response;\n  };\n\n  -- Stream\n  define stream tutorialAppInputStream (deviceID string, roomNo int, temperature double);\n\n  -- Table\n  define table tutorialAppOutputTable (ID string, temperature double);\n\n  @info(name=\'Query\')\n  select concatFn(roomNo,\'-\',deviceID) as id, temperature\n  from tutorialAppInputStream\n  insert into tutorialAppOutputTable;`;\n\nconst run = async function () {\n  try {\n    const connection = new APIRequest(federationUrl);\n\n    /* -------------------- Log in (nemo@nautilus.com/xxxxxx) -------------------- */\n\n    const { tenant } = await connection.login(email, password);\n\n    console.log("Logged in successfully using", tenant);\n\n    /* ---------------------------- Create stream app ---------------------------- */\n    \n    try {\n      const app = await connection.req("/_fabric/_system/_api/streamapps", {\n        body: {\n          definition: streamApp,\n          regions: []\n        },\n        method: "POST"\n      });\n      console.log("Stream app created successfully", app);\n    } catch (e) {\n      if (e.status === 409) {\n        console.log(\n          "Stream app already exists, skipping creation of stream app"\n        );\n      } else {\n        console.log("Error while creating stream app");\n        throw e;\n      }\n    }\n\n    /* --------------------------- Activate stream app --------------------------- */\n\n    await connection.req(\n      `/_fabric/_system/_api/streamapps/${streamAppName}/active?active=true`,\n      {\n        method: "PATCH"\n      }\n    );\n\n    console.log("Activating stream app...", streamAppName);\n\n    await new Promise((resolve) => setTimeout(resolve, 10000));\n\n    console.log("Stream app activated successfully");\n\n    /* ------------------ Publish messages to sample stream app ------------------ */\n    \n    const region = isGlobal ? "c8global" : "c8local";\n    const streamName = `${region}s.${stream}`;\n\n    // Fetch local URL in case the stream is local (which is defined in the stream app)\n    const localDcDetails = await connection.req(`/datacenter/local`, {\n      method: "GET"\n    });\n\n    const dcUrl = localDcDetails.tags.url;\n\n    const url = isGlobal ? federationName : `api-${dcUrl}`;\n\n    const otpProducer = await connection.req(`/apid/otp`, {\n      method: "POST"\n    });\n\n    const producerUrl = `wss://${url}/_ws/ws/v2/producer/persistent/${tenant}/${region}._system/${streamName}?otp=${otpProducer.otp}`;\n\n    /* -------------------------- Initalize producer -------------------------- */\n\n    const producer = new WebSocket(producerUrl);\n\n    producer.onopen = function () {\n      console.log("WebSocket:Producer is open now for " + streamName);\n    };\n\n    producer.onerror = function () {\n      console.log(\n        "Failed to establish WebSocket:Producer connection for " + streamName\n      );\n    };\n\n    producer.onclose = function () {\n      console.log("Closed WebSocket:Producer connection for " + streamName);\n    };\n\n    producer.onmessage = function () {\n      console.log("WebSocket:Producer message sent successfully");\n    };\n\n    await new Promise((resolve) => setTimeout(resolve, 10000));\n\n    const inputData = [\n      {\n        deviceID: "AD11",\n        roomNo: 200,\n        temperature: 18\n      },\n      { deviceID: "AD11", roomNo: 201, temperature: 47 }\n    ];\n\n    producer.send(\n      JSON.stringify({\n        payload: Buffer.from((JSON.stringify(inputData[0]))).toString(\'base64\')\n      })\n    );\n\n    await new Promise((resolve) => setTimeout(resolve, 10000));\n\n    producer.send(\n      JSON.stringify({\n        payload: Buffer.from((JSON.stringify(inputData[1]))).toString(\'base64\')\n      })\n    );\n\n    await new Promise((resolve) => setTimeout(resolve, 10000));\n\n    producer.close();\n\n    /* ----------------------------- Verify results ----------------------------- */\n\n    const selectQuery = "FOR doc IN tutorialAppOutputTable return doc";\n\n    const result = await connection.req(`/_fabric/_system/_api/cursor`, {\n      body: {\n        id: "tutorialStreamAppQuery",\n        query: selectQuery,\n        bindVars: {}\n      },\n      method: "POST"\n    });\n\n    console.log("Input data sent ---\x3e", inputData);\n    console.log("Output data received ---\x3e", result.result);\n\n    /* ---------------------------- Delete stream app ---------------------------- */\n    \n    const deletion = await connection.req(\n      `/_fabric/_system/_api/streamapps/${streamAppName}`,\n      {\n        method: "DELETE"\n      }\n    );\n\n    console.log("Stream app deleted successfully", deletion);\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nrun();\n')))))}m.isMDXComponent=!0},25369:(e,n,t)=>{t.d(n,{Z:()=>o});const o=t.p+"assets/images/gdn-api-browser-a97ea76030a8c372c2254418f1e67c27.png"}}]);