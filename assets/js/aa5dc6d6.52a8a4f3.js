"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[97279],{3905:(e,n,a)=>{a.d(n,{Zo:()=>p,kt:()=>d});var r=a(67294);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function u(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var s=r.createContext({}),l=function(e){var n=r.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):u(u({},n),e)),a},p=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=l(a),d=t,c=m["".concat(s,".").concat(d)]||m[d]||g[d]||i;return a?r.createElement(c,u(u({ref:n},p),{},{components:a})):r.createElement(c,u({ref:n},p))}));function d(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=a.length,u=new Array(i);u[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:t,u[1]=o;for(var l=2;l<i;l++)u[l]=a[l];return r.createElement.apply(null,u)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},15548:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>u,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=a(87462),t=(a(67294),a(3905));const i={sidebar_position:6,title:"Grouping"},u=void 0,o={unversionedId:"queryworkers/c8ql/examples/grouping",id:"queryworkers/c8ql/examples/grouping",title:"Grouping",description:"To group results by arbitrary criteria, C8QL provides the COLLECT keyword. COLLECT will perform a grouping, but no aggregation. Aggregation can still be added in the query if required.",source:"@site/docs/queryworkers/c8ql/examples/grouping.md",sourceDirName:"queryworkers/c8ql/examples",slug:"/queryworkers/c8ql/examples/grouping",permalink:"/docs/queryworkers/c8ql/examples/grouping",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/examples/grouping.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Grouping"},sidebar:"defaultSidebar",previous:{title:"Dynamic Attribute Names",permalink:"/docs/queryworkers/c8ql/examples/dynamic-attribute-names"},next:{title:"Joins",permalink:"/docs/queryworkers/c8ql/examples/joins"}},s={},l=[{value:"Ensuring uniqueness",id:"ensuring-uniqueness",level:2},{value:"Fetching group values",id:"fetching-group-values",level:2},{value:"Variable Expansion",id:"variable-expansion",level:2},{value:"Grouping by multiple criteria",id:"grouping-by-multiple-criteria",level:2},{value:"Counting group values",id:"counting-group-values",level:2},{value:"Aggregation",id:"aggregation",level:2},{value:"Post-aggregation",id:"post-aggregation",level:2},{value:"Post-filtering aggregated data",id:"post-filtering-aggregated-data",level:2}],p={toc:l};function g(e){let{components:n,...a}=e;return(0,t.kt)("wrapper",(0,r.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("p",null,"To group results by arbitrary criteria, C8QL provides the ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," keyword. ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," will perform a grouping, but no aggregation. Aggregation can still be added in the query if required."),(0,t.kt)("h2",{id:"ensuring-uniqueness"},"Ensuring uniqueness"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," can be used to make a result set unique. The following query will return each distinct ",(0,t.kt)("inlineCode",{parentName:"p"},"age")," attribute value only once:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    COLLECT age = u.age\n    RETURN age\n")),(0,t.kt)("p",null,"This is grouping without tracking the group values, but just the group criterion (",(0,t.kt)("em",{parentName:"p"},"age"),") value."),(0,t.kt)("p",null,"Grouping can also be done on multiple levels using ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    COLLECT status = u.status, age = u.age\n    RETURN { status, age }\n")),(0,t.kt)("p",null,"Alternatively ",(0,t.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," can be used to make a result set unique. ",(0,t.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," supports a single criterion only:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    RETURN DISTINCT u.age\n")),(0,t.kt)("p",null,"Note: the order of results is undefined for ",(0,t.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT"),"."),(0,t.kt)("h2",{id:"fetching-group-values"},"Fetching group values"),(0,t.kt)("p",null,"To group users by age, and return the names of the users with the highest ages, we'll issue a query like this:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT age = u.age INTO usersByAge\n    SORT age DESC LIMIT 0, 5\n    RETURN {\n        age,\n        users: usersByAge[*].u.name\n    }\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "age": 37, "users": [ "John", "Sophia" ] },\n  { "age": 36, "users": [ "Fred", "Emma" ] },\n  { "age": 34, "users": [ "Madison" ] },\n  { "age": 33, "users": [ "Chloe", "Michael" ] },\n  { "age": 32, "users": [ "Alexander" ] }\n]\n')),(0,t.kt)("p",null,"The query will put all users together by their ",(0,t.kt)("em",{parentName:"p"},"age")," attribute. There will be one result document per distinct ",(0,t.kt)("em",{parentName:"p"},"age")," value (let aside the ",(0,t.kt)("inlineCode",{parentName:"p"},"LIMIT"),"). For each group, we have access to the matching document via the ",(0,t.kt)("inlineCode",{parentName:"p"},"usersByAge")," variable introduced in the ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement."),(0,t.kt)("h2",{id:"variable-expansion"},"Variable Expansion"),(0,t.kt)("p",null,"The ",(0,t.kt)("inlineCode",{parentName:"p"},"usersByAge")," variable contains the full documents found, and as we're only interested in user names, we'll use the expansion operator ",(0,t.kt)("i",null,"[*]")," to extract just the ",(0,t.kt)("inlineCode",{parentName:"p"},"name")," attribute of all user documents in each group:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"usersByAge[*].u.name\n")),(0,t.kt)("p",null,"The ",(0,t.kt)("i",null,"[*]")," expansion operator is just a handy short-cut. We could also write\na subquery:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"( FOR temp IN usersByAge RETURN temp.u.name )\n")),(0,t.kt)("h2",{id:"grouping-by-multiple-criteria"},"Grouping by multiple criteria"),(0,t.kt)("p",null,"To group by multiple criteria, we'll use multiple arguments in the ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," clause. For example, to group users by ",(0,t.kt)("inlineCode",{parentName:"p"},"ageGroup")," (a derived value we need to calculate first) and then by ",(0,t.kt)("inlineCode",{parentName:"p"},"gender"),", we'll do:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender INTO group\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender\n    }\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "ageGroup": 35, "gender": "f" },\n  { "ageGroup": 35, "gender": "m" },\n  { "ageGroup": 30, "gender": "f" },\n  { "ageGroup": 30, "gender": "m" },\n  { "ageGroup": 25, "gender": "f" },\n  { "ageGroup": 25, "gender": "m" }\n]\n')),(0,t.kt)("h2",{id:"counting-group-values"},"Counting group values"),(0,t.kt)("p",null,"If the goal is to count the number of values in each group, C8QL provides the special ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT WITH COUNT INTO")," syntax. This is a simple variant for grouping with an additional group length calculation:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender WITH COUNT INTO numUsers\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers\n    }\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "ageGroup": 35, "gender": "f", "numUsers": 2 },\n  { "ageGroup": 35, "gender": "m", "numUsers": 2 },\n  { "ageGroup": 30, "gender": "f", "numUsers": 4 },\n  { "ageGroup": 30, "gender": "m", "numUsers": 4 },\n  { "ageGroup": 25, "gender": "f", "numUsers": 2 },\n  { "ageGroup": 25, "gender": "m", "numUsers": 2 }\n]\n')),(0,t.kt)("h2",{id:"aggregation"},"Aggregation"),(0,t.kt)("p",null,"Adding further aggregation is also simple in C8QL by using an ",(0,t.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause in the ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender\n    AGGREGATE numUsers = LENGTH(1),\n              minAge = MIN(u.age),\n              maxAge = MAX(u.age)\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers,\n        minAge,\n        maxAge\n    }\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 35,\n    "gender": "f",\n    "numUsers": 2,\n    "minAge": 36,\n    "maxAge": 39,\n  },\n  {\n    "ageGroup": 35,\n    "gender": "m",\n    "numUsers": 2,\n    "minAge": 35,\n    "maxAge": 39,\n  },\n  ...\n]\n')),(0,t.kt)("p",null,"We have used the aggregate functions ",(0,t.kt)("inlineCode",{parentName:"p"},"LENGTH")," here (it returns the length of an array). This is the equivalent to SQL's ",(0,t.kt)("inlineCode",{parentName:"p"},"SELECT g, COUNT(*) FROM ... GROUP BY g"),". In addition to ",(0,t.kt)("inlineCode",{parentName:"p"},"LENGTH")," C8QL also provides ",(0,t.kt)("inlineCode",{parentName:"p"},"MAX"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"MIN"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"SUM")," and ",(0,t.kt)("inlineCode",{parentName:"p"},"AVERAGE"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"VARIANCE_POPULATION"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"VARIANCE_SAMPLE"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"STDDEV_POPULATION")," and ",(0,t.kt)("inlineCode",{parentName:"p"},"STDDEV_SAMPLE")," as basic aggregation functions."),(0,t.kt)("p",null,"In C8QL all aggregation functions can be run on arrays only. If an aggregation function is run on anything that is not an array, a warning will be produced and the result will be ",(0,t.kt)("em",{parentName:"p"},"null"),"."),(0,t.kt)("p",null,"Using an ",(0,t.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause will ensure the aggregation is run while the groups are built in the collect operation. This is normally more efficient than collecting all group values for all groups and then doing a post-aggregation."),(0,t.kt)("h2",{id:"post-aggregation"},"Post-aggregation"),(0,t.kt)("p",null,"Aggregation can also be performed after a ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," operation using other C8QL constructs, though performance-wise this is often inferior to using ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," with ",(0,t.kt)("inlineCode",{parentName:"p"},"AGGREGATE"),"."),(0,t.kt)("p",null,"The same query as before can be turned into a post-aggregation query as shown below. Note that this query will build and pass on all group values for all groups inside the variable ",(0,t.kt)("em",{parentName:"p"},"g"),", and perform the aggregation at the latest possible stage:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender INTO g\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers: LENGTH(g[*]),\n        minAge: MIN(g[*].u.age),\n        maxAge: MAX(g[*].u.age)\n    }\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 35,\n    "gender": "f",\n    "numUsers": 2,\n    "minAge": 36,\n    "maxAge": 39,\n  },\n  {\n    "ageGroup": 35,\n    "gender": "m",\n    "numUsers": 2,\n    "minAge": 35,\n    "maxAge": 39,\n  },\n  ...\n]\n')),(0,t.kt)("p",null,"This is in constrast to the previous query that used an ",(0,t.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause to perform the aggregation during the collect operation, at the earliest possible stage."),(0,t.kt)("h2",{id:"post-filtering-aggregated-data"},"Post-filtering aggregated data"),(0,t.kt)("p",null,"To filter the results of a grouping or aggregation operation (i.e. something similar to ",(0,t.kt)("inlineCode",{parentName:"p"},"HAVING")," in SQL), simply add another ",(0,t.kt)("inlineCode",{parentName:"p"},"FILTER")," clause after the ",(0,t.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement."),(0,t.kt)("p",null,"For example, to get the 3 ",(0,t.kt)("inlineCode",{parentName:"p"},"ageGroup"),"s with the most users in them:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5 INTO group\n    LET numUsers = LENGTH(group)\n    FILTER numUsers > 2 /* group must contain at least 3 users in order to qualify */\n    SORT numUsers DESC\n    LIMIT 0, 3\n    RETURN {\n        "ageGroup": ageGroup,\n        "numUsers": numUsers,\n        "users": group[*].u.name\n    }\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 30,\n    "numUsers": 8,\n    "users": [\n      "Abigail",\n      "Madison",\n      "Anthony",\n      "Alexander",\n      "Isabella",\n      "Chloe",\n      "Daniel",\n      "Michael"\n    ]\n  },\n  {\n    "ageGroup": 25,\n    "numUsers": 4,\n    "users": [\n      "Mary",\n      "Mariah",\n      "Jim",\n      "Diego"\n    ]\n  },\n  {\n    "ageGroup": 35,\n    "numUsers": 4,\n    "users": [\n      "Fred",\n      "John",\n      "Emma",\n      "Sophia"\n    ]\n  }\n]\n')),(0,t.kt)("p",null,"To increase readability, the repeated expression ",(0,t.kt)("inlineCode",{parentName:"p"},"LENGTH(group)")," was put into a variable ",(0,t.kt)("inlineCode",{parentName:"p"},"numUsers"),". The ",(0,t.kt)("inlineCode",{parentName:"p"},"FILTER")," on ",(0,t.kt)("inlineCode",{parentName:"p"},"numUsers")," is the equivalent an SQL ",(0,t.kt)("inlineCode",{parentName:"p"},"HAVING")," clause."))}g.isMDXComponent=!0}}]);