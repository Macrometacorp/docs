"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[37513],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},l=Object.keys(e);for(o=0;o<l.length;o++)n=l[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)n=l[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=p(n),g=a,N=d["".concat(s,".").concat(g)]||d[g]||c[g]||l;return n?o.createElement(N,r(r({ref:t},u),{},{components:n})):o.createElement(N,r({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var p=2;p<l;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},28953:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const l={title:"Geo Functions"},r=void 0,i={unversionedId:"queryworkers/c8ql/functions/geo",id:"queryworkers/c8ql/functions/geo",title:"Geo Functions",description:"Geo utility functions",source:"@site/docs/queryworkers/c8ql/functions/geo.md",sourceDirName:"queryworkers/c8ql/functions",slug:"/queryworkers/c8ql/functions/geo",permalink:"/docs/queryworkers/c8ql/functions/geo",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/main/docs/queryworkers/c8ql/functions/geo.md",tags:[],version:"current",frontMatter:{title:"Geo Functions"},sidebar:"defaultSidebar",previous:{title:"Fulltext Functions",permalink:"/docs/queryworkers/c8ql/functions/fulltext"},next:{title:"Hash Functions",permalink:"/docs/queryworkers/c8ql/functions/hash"}},s={},p=[{value:"Geo utility functions",id:"geo-utility-functions",level:2},{value:"DISTANCE()",id:"distance",level:3},{value:"GEO_CONTAINS()",id:"geo_contains",level:3},{value:"GEO_DISTANCE()",id:"geo_distance",level:3},{value:"GEO_AREA()",id:"geo_area",level:3},{value:"GEO_EQUALS()",id:"geo_equals",level:3},{value:"GEO_INTERSECTS()",id:"geo_intersects",level:3},{value:"GeoJSON Constructors",id:"geojson-constructors",level:2},{value:"GEO_LINESTRING()",id:"geo_linestring",level:3},{value:"GEO_MULTILINESTRING()",id:"geo_multilinestring",level:3},{value:"GEO_MULTIPOINT()",id:"geo_multipoint",level:3},{value:"GEO_POINT()",id:"geo_point",level:3},{value:"GEO_POLYGON()",id:"geo_polygon",level:3},{value:"GEO_MULTIPOLYGON()",id:"geo_multipolygon",level:3}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"geo-utility-functions"},"Geo utility functions"),(0,a.kt)("p",null,"The following helper functions ",(0,a.kt)("strong",{parentName:"p"},"can")," use geo indexes, but do not have to in all cases. You can use all of these functions in combination with each other, and if you have configured a geo index it may be utilized, see ",(0,a.kt)("a",{parentName:"p",href:"../../../collections/indexing/working-with-indexes#geo-spatial-indexes"},"Geo Indexing"),"."),(0,a.kt)("h3",{id:"distance"},"DISTANCE()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"DISTANCE(latitude1, longitude1, latitude2, longitude2) \u2192 distance")),(0,a.kt)("p",null,"Calculate the distance between two arbitrary coordinates in meters (as birds would fly). The value is computed using the haversine formula, which is based on a spherical Earth model. It's fast to compute and is accurate to around 0.3%, which is sufficient for most use cases such as location-aware services."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"latitude1")," (number): the latitude portion of the first coordinate"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"longitude1")," (number): the longitude portion of the first coordinate"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"latitude2")," (number): the latitude portion of the second coordinate"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"longitude2")," (number): the longitude portion of the second coordinate"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"distance")," (number): the distance between both coordinates in ",(0,a.kt)("strong",{parentName:"li"},"meters"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// Distance from Brandenburg Gate (Berlin) to (Cologne)\nDISTANCE(52.5163, 13.3777, 50.9322, 6.94) // 476918.89688380965 (~477km)\n\n// Sort a small number of documents based on distance to Central Park (New York)\nFOR doc IN doc // e.g. documents returned by a traversal\n  SORT DISTANCE(doc.latitude, doc.longitude, 40.78, -73.97)\n  RETURN doc\n")),(0,a.kt)("h3",{id:"geo_contains"},"GEO_CONTAINS()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_CONTAINS(geoJsonA, geoJsonB) \u2192 bool")),(0,a.kt)("p",null,"Checks whether the ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geojson-mode"},"GeoJSON object")," ",(0,a.kt)("inlineCode",{parentName:"p"},"geoJsonA")," fully contains ",(0,a.kt)("inlineCode",{parentName:"p"},"geoJsonB")," (Every point in B is also in A). The object ",(0,a.kt)("inlineCode",{parentName:"p"},"geoJsonA")," has to be of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Polygon")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiPolygon"),", other types are not supported because containment is ill defined. This function can be ",(0,a.kt)("strong",{parentName:"p"},"optimized")," by a S2 based ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geo-spatial-indexes"},"geospatial index"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonA")," (object): first GeoJSON object or coordinate array (in longitude, latitude order)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonB")," (object): second GeoJSON object or coordinate array (in longitude, latitude order)"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"bool")," (bool): true when every point in B is also contained in A, false otherwise")),(0,a.kt)("h3",{id:"geo_distance"},"GEO_DISTANCE()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_DISTANCE(geoJsonA, geoJsonB, ellipsoid) \u2192 distance")),(0,a.kt)("p",null,"Return the distance between two GeoJSON objects, measured from the ",(0,a.kt)("strong",{parentName:"p"},"centroid")," of each shape. For a list of supported types see the ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geo-spatial-indexes"},"geo index page"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonA")," (object): first GeoJSON object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonB")," (object): second GeoJSON object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ellipsoid")," (string, ",(0,a.kt)("em",{parentName:"li"},"optional"),"): reference ellipsoid to use. Supported are ",(0,a.kt)("inlineCode",{parentName:"li"},'"sphere"')," (default) and ",(0,a.kt)("inlineCode",{parentName:"li"},'"wgs84"'),"."),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"distance")," (number): the distance between the centroid points of the two objects on the reference ellipsoid")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'LET polygon = {\n  type: "Polygon",\n  coordinates: [[[-11.5, 23.5], [-10.5, 26.1], [-11.2, 27.1], [-11.5, 23.5]]]\n}\nFOR doc IN collectionName\n  LET distance = GEO_DISTANCE(doc.geometry, polygon) // calculates the distance\n  RETURN distance\n')),(0,a.kt)("h3",{id:"geo_area"},"GEO_AREA()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_AREA(geoJson, ellipsoid) \u2192 area")),(0,a.kt)("p",null,"Return the area for a polygon or multi-polygon on a sphere with the average Earth radius, or an ellipsoid. For a list of supported types see the ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geo-spatial-indexes"},"geo index page"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object): a GeoJSON object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ellipsoid")," (string, ",(0,a.kt)("em",{parentName:"li"},"optional"),"): reference ellipsoid to use. Supported are ",(0,a.kt)("inlineCode",{parentName:"li"},'"sphere"')," (default) and ",(0,a.kt)("inlineCode",{parentName:"li"},'"wgs84"'),"."),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"area")," (number): the area in square meters of the polygon")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'LET polygon = {\n  type: "Polygon",\n  coordinates: [[[-11.5, 23.5], [-10.5, 26.1], [-11.2, 27.1], [-11.5, 23.5]]]\n}\nRETURN GEO_AREA(polygon, "wgs84")\n')),(0,a.kt)("h3",{id:"geo_equals"},"GEO_EQUALS()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_EQUALS(geoJsonA, geoJsonB) \u2192 bool")),(0,a.kt)("p",null,"Checks whether two GeoJSON objects are equal or not. For a list of supported types see the ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geo-spatial-indexes"},"geo index page"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonA")," (object): first GeoJSON object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonB")," (object): second GeoJSON object."),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"bool")," (bool): true for equality.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"LET polygonA = GEO_POLYGON([\n  [-11.5, 23.5], [-10.5, 26.1], [-11.2, 27.1], [-11.5, 23.5]\n])\nLET polygonB = GEO_POLYGON([\n  [-11.5, 23.5], [-10.5, 26.1], [-11.2, 27.1], [-11.5, 23.5]\n])\nRETURN GEO_EQUALS(polygonA, polygonB) // true\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"LET polygonA = GEO_POLYGON([\n  [-11.1, 24.0], [-10.5, 26.1], [-11.2, 27.1], [-11.1, 24.0]\n])\nLET polygonB = GEO_POLYGON([\n  [-11.5, 23.5], [-10.5, 26.1], [-11.2, 27.1], [-11.5, 23.5]\n])\nRETURN GEO_EQUALS(polygonA, polygonB) // false\n")),(0,a.kt)("h3",{id:"geo_intersects"},"GEO_INTERSECTS()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_INTERSECTS(geoJsonA, geoJsonB) \u2192 bool")),(0,a.kt)("p",null,"Checks whether the ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geojson-mode"},"GeoJSON object")," ",(0,a.kt)("inlineCode",{parentName:"p"},"geoJsonA")," intersects with ",(0,a.kt)("inlineCode",{parentName:"p"},"geoJsonB")," (i.e. at least one point in B is also A or vice-versa). This function can be ",(0,a.kt)("strong",{parentName:"p"},"optimized")," by a S2 based ",(0,a.kt)("a",{parentName:"p",href:"/docs/collections/indexing/geo-indexes#geo-spatial-indexes"},"geospatial index"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonA")," (object): first GeoJSON object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"geoJsonB")," (object): second GeoJSON object."),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"bool")," (bool): true if B intersects A, false otherwise")),(0,a.kt)("h2",{id:"geojson-constructors"},"GeoJSON Constructors"),(0,a.kt)("p",null,"The following helper functions are available to easily create valid GeoJSON output. In all cases you can write equivalent JSON yourself, but these functions will help you to make all your C8QL queries shorter and easier to read."),(0,a.kt)("h3",{id:"geo_linestring"},"GEO_LINESTRING()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_LINESTRING(points) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a GeoJSON LineString. Needs at least two longitude/latitude pairs."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"points")," (array): number array of longitude/latitude pairs"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object): a valid GeoJSON LineString")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_LINESTRING([\n    [35, 10], [45, 45]\n])\n")),(0,a.kt)("h3",{id:"geo_multilinestring"},"GEO_MULTILINESTRING()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_MULTILINESTRING(points) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a GeoJSON MultiLineString. Needs at least two elements consisting valid LineStrings coordinate arrays."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"points")," (array): array of LineStrings"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object): a valid GeoJSON MultiLineString")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_MULTILINESTRING([\n    [[100.0, 0.0], [101.0, 1.0]],\n    [[102.0, 2.0], [101.0, 2.3]]\n])\n")),(0,a.kt)("h3",{id:"geo_multipoint"},"GEO_MULTIPOINT()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_MULTIPOINT(points) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a GeoJSON LineString. Needs at least two longitude/latitude pairs."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"points")," (array): number array of longitude/latitude pairs"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object): a valid GeoJSON Point")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_MULTIPOINT([\n    [35, 10], [45, 45]\n])\n")),(0,a.kt)("h3",{id:"geo_point"},"GEO_POINT()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_POINT(longitude, latitude) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a valid GeoJSON Point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"longitude")," (number): the longitude portion of the point"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"latitude")," (number): the latitude portion of the point"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object): a GeoJSON Point")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_POINT(1.0, 2.0)\n")),(0,a.kt)("h3",{id:"geo_polygon"},"GEO_POLYGON()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_POLYGON(points) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a GeoJSON Polygon. Needs at least one array representing a loop. Each loop consists of an array with at least three longitude/latitude pairs. The first loop must be the outermost, while any subsequent loops will be interpreted as holes."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"points")," (array): array of (arrays of) longitude/latitude pairs"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object","|","null): a valid GeoJSON Polygon")),(0,a.kt)("p",null,"Simple Polygon:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_POLYGON([\n    [0.0, 0.0], [7.5, 2.5], [0.0, 5.0]\n])\n")),(0,a.kt)("p",null,"Advanced Polygon with a hole inside:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_POLYGON([\n    [[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]],\n    [[20, 30], [35, 35], [30, 20], [20, 30]]\n])\n")),(0,a.kt)("h3",{id:"geo_multipolygon"},"GEO_MULTIPOLYGON()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GEO_MULTIPOLYGON(polygons) \u2192 geoJson")),(0,a.kt)("p",null,"Construct a GeoJSON MultiPolygon. Needs at least two Polygons inside. See ",(0,a.kt)("a",{parentName:"p",href:"#geo_polygon"},"GEO_POLYGON()")," for the rules of Polygon construction."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"polygons")," (array): array of arrays of array of longitude/latitude pairs"),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("strong",{parentName:"li"},"geoJson")," (object","|","null): a valid GeoJSON MultiPolygon")),(0,a.kt)("p",null,"MultiPolygon comprised of a simple Polygon and a Polygon with hole:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"RETURN GEO_MULTIPOLYGON([\n    [\n        [[40, 40], [20, 45], [45, 30], [40, 40]]\n    ],\n    [\n        [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20], [20, 35]],\n        [[30, 20], [20, 15], [20, 25], [30, 20]]\n    ]\n])\n")))}c.isMDXComponent=!0}}]);