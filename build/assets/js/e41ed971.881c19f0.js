"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7738],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),c=s(n),d=r,k=c["".concat(o,".").concat(d)]||c[d]||m[d]||l;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,i[1]=p;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},29594:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return p},metadata:function(){return s},toc:function(){return m}});var a=n(87462),r=n(63366),l=(n(67294),n(3905)),i=["components"],p={sidebar_position:4},o="Text",s={unversionedId:"cep/reference/extensions/mappers/text",id:"cep/reference/extensions/mappers/text",title:"Text",description:"This is an extension that converts text messages to/from stream processor events.",source:"@site/docs/cep/reference/extensions/mappers/text.md",sourceDirName:"cep/reference/extensions/mappers",slug:"/cep/reference/extensions/mappers/text",permalink:"/docs/cep/reference/extensions/mappers/text",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"KeyValue",permalink:"/docs/cep/reference/extensions/mappers/keyvalue"},next:{title:"Introduction",permalink:"/docs/c8ql/introduction"}},u={},m=[{value:"Features",id:"features",level:2},{value:"text (Sink Mapper)",id:"text-sink-mapper",level:2},{value:"text (Source Mapper)",id:"text-source-mapper",level:2}],c={toc:m};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"text"},"Text"),(0,l.kt)("p",null,"This is an extension that converts text messages to/from stream processor events."),(0,l.kt)("h2",{id:"features"},"Features"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#text-sink-mapper"},"text (Sink Mapper)"))),(0,l.kt)("p",{parentName:"li"},"  This extension is a Event to Text output mapper. Transports that publish text messages can utilize this extension to convert the events to text messages. Users can use a pre-defined text format where event conversion is carried out without any additional configurations, or use custom placeholder(using ",(0,l.kt)("inlineCode",{parentName:"p"},"{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}"),") to map custom text messages. Again, you can also enable mustache based custom mapping. In mustache based custom mapping you can use custom placeholder (using ",(0,l.kt)("inlineCode",{parentName:"p"},"{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"{{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}}"),") to map custom text. In mustache based custom mapping, all variables are HTML escaped by default."),(0,l.kt)("p",{parentName:"li"},"  For example:\n",(0,l.kt)("inlineCode",{parentName:"p"},"&")," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},"&amp;"),"\n",(0,l.kt)("inlineCode",{parentName:"p"},'"')," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},"&quot;"),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"=")," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},"&#61;")),(0,l.kt)("p",{parentName:"li"},"  If you want to return unescaped HTML, use the triple mustache ",(0,l.kt)("inlineCode",{parentName:"p"},"{{{")," instead of double ",(0,l.kt)("inlineCode",{parentName:"p"},"{{"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#text-source-mapper"},"text (Source Mapper)"))),(0,l.kt)("p",{parentName:"li"},"  This extension is a text to event input mapper. Transports that accept text messages can utilize this extension to convert the incoming text message to event. Users can either use a pre-defined text format where event conversion happens without any additional configurations, or specify a regex to map a text message using custom configurations."))),(0,l.kt)("h2",{id:"text-sink-mapper"},"text (Sink Mapper)"),(0,l.kt)("p",null,"This extension is a Event to Text output mapper. Transports that publish text messages can utilize this extension to convert the events to text messages. Users can use a pre-defined text format where event conversion is carried out without any additional configurations, or use custom placeholder(using ",(0,l.kt)("inlineCode",{parentName:"p"},"{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}"),") to map custom text messages."),(0,l.kt)("p",null,"Again, you can also enable mustache based custom mapping. In mustache based custom mapping you can use custom placeholder (using ",(0,l.kt)("inlineCode",{parentName:"p"},"{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"{{{")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"}}}"),") to map custom text. In mustache based custom mapping, all variables are HTML escaped by default.For example:",(0,l.kt)("inlineCode",{parentName:"p"},"&")," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},'&amp;``"')," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},"&quot;``=")," is replaced with ",(0,l.kt)("inlineCode",{parentName:"p"},"&#61;")),(0,l.kt)("p",null,"If you want to return unescaped HTML, use the triple mustache ",(0,l.kt)("inlineCode",{parentName:"p"},"{{{")," instead of double ",(0,l.kt)("inlineCode",{parentName:"p"},"{{"),"."),(0,l.kt)("p",null,"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'@sink(..., @map(type="text", event.grouping.enabled="<BOOL>", delimiter="<STRING>", new.line.character="<STRING>", mustache.enabled="<BOOL>")\n')),(0,l.kt)("p",null,"QUERY PARAMETERS"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Possible Data Types"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Dynamic"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"event.grouping.enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"If this parameter is set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true"),", events are grouped via a delimiter when multiple events are received. It is required to specify a value for the ",(0,l.kt)("inlineCode",{parentName:"td"},"delimiter")," parameter when the value for this parameter is ",(0,l.kt)("inlineCode",{parentName:"td"},"true"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delimiter"),(0,l.kt)("td",{parentName:"tr",align:null},"This parameter specifies how events are separated when a grouped event is received. This must be a whole line and not a single character."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("del",{parentName:"td"}),(0,l.kt)("del",{parentName:"td"}),"~~"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"new.line.character"),(0,l.kt)("td",{parentName:"tr",align:null},"This attribute indicates the new line character of the event that is expected to be received. This is used mostly when communication between 2 types of operating systems is expected. For example, Linux uses ",(0,l.kt)("inlineCode",{parentName:"td"},"\\n")," whereas Windows uses ",(0,l.kt)("inlineCode",{parentName:"td"},"\\r\\n")," as the end of line character."),(0,l.kt)("td",{parentName:"tr",align:null},"\\n"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mustache.enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"If this parameter is set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true"),", then mustache mapping gets enabled forcustom text mapping."),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("p",null,"EXAMPLE 1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@sink(type='inMemory', topic='stock', @map(type='text'))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a default text input mapping. The expected output is\nas follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'symbol:"GDN",\nprice:55.6,\nvolume:100\n')),(0,l.kt)("p",null,"EXAMPLE 2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@sink(type='inMemory', topic='stock', @map(type='text', event.grouping.enabled='true'))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a default text input mapping with event grouping.\nThe expected output is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'symbol:"GDN",\nprice:55.6,\nvolume:100\n~~~~~~~~~~\nsymbol:"GDN",\nprice:55.6,\nvolume:100\n')),(0,l.kt)("p",null,"EXAMPLE 3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@sink(type='inMemory', topic='stock', @map(type='text',  @payload(\"SensorID : {{symbol}}/{{volume}}, SensorPrice : Rs{{price}}/=, Value : {{volume}}ml\")))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a custom text mapping. The expected output is as\nfollows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"SensorID : gdn/100, \nSensorPrice : Rs1000/=, \nValue : 100ml \n")),(0,l.kt)("p",null,"for the following stream processor event."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{gdn,1000,100}\n")),(0,l.kt)("p",null,"EXAMPLE 4"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@sink(type='inMemory', topic='stock', @map(type='text', event.grouping.enabled='true', @payload(\"Stock price of {{symbol}} is {{price}}\")))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a custom text mapping with event grouping. The\nexpected output is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Stock price of GDN is 55.6\n~~~~~~~~~~\nStock price of GDN is 55.6\n~~~~~~~~~~\nStock price of GDN is 55.6\n")),(0,l.kt)("p",null,"for the following stream processor event."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{GDN,55.6,10}\n")),(0,l.kt)("p",null,"EXAMPLE 5"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@sink(type='inMemory', topic='stock', @map(type='text', mustache.enabled='true',  @payload(\"SensorID : {{{symbol}}}/{{{volume}}}, SensorPrice : Rs{{{price}}}/=, Value : {{{volume}}}ml\")))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a custom text mapping to return unescaped HTML. The\nexpected output is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"SensorID : a&b/100,\nSensorPrice : Rs1000/=,\nValue : 100ml\n")),(0,l.kt)("p",null,"for the following stream processor event."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{a&b,1000,100}\n")),(0,l.kt)("h2",{id:"text-source-mapper"},"text (Source Mapper)"),(0,l.kt)("p",null,"This extension is a text to event input mapper. Transports that accept text messages can utilize this extension to convert the incoming text message to event. Users can either use a pre-defined text format where event conversion happens without any additional configurations, or specify a regex to map a text message using custom configurations."),(0,l.kt)("p",null,"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'@source(..., @map(type="text", regex.groupid="<STRING>", fail.on.missing.attribute="<BOOL>", event.grouping.enabled="<BOOL>", delimiter="<STRING>", new.line.character="<STRING>")\n')),(0,l.kt)("p",null,"QUERY PARAMETERS"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Possible Data Types"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Dynamic"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"regex.groupid"),(0,l.kt)("td",{parentName:"tr",align:null},"This parameter specifies a regular expression group. The ",(0,l.kt)("inlineCode",{parentName:"td"},"groupid")," can be any capital letter (e.g., regex.A,regex.B .. etc). You can specify any number of regular expression groups. In the attribute annotation, you need to map all attributes to the regular expression group with the matching group index. If you need to to enable custom mapping, it is required to specifythe matching group for each and every attribute."),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"No"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fail.on.missing.attribute"),(0,l.kt)("td",{parentName:"tr",align:null},"This parameter specifies how unknown attributes should be handled. If it is set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true")," a message is dropped if its execution fails, or if one or more attributes do not have values. If this parameter is set to ",(0,l.kt)("inlineCode",{parentName:"td"},"false"),", null values are assigned to attributes with missing values, and messages with such attributes are not dropped."),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"event.grouping.enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"This parameter specifies whether event grouping is enabled or not. To receive a group of events together and generate multiple events, this parameter must be set to ",(0,l.kt)("inlineCode",{parentName:"td"},"true"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"BOOL"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delimiter"),(0,l.kt)("td",{parentName:"tr",align:null},"This parameter specifies how events must be separated when multiple events are received. This must be whole line and not a single character."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("del",{parentName:"td"}),(0,l.kt)("del",{parentName:"td"}),"~~"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"new.line.character"),(0,l.kt)("td",{parentName:"tr",align:null},"This attribute indicates the new line character of the event that is expected to be received. This is used mostly when communication between 2 types of operating systems is expected. For example, Linux uses ",(0,l.kt)("inlineCode",{parentName:"td"},"\\n")," as the end of line character whereas windows uses ",(0,l.kt)("inlineCode",{parentName:"td"},"\\r\\n"),"."),(0,l.kt)("td",{parentName:"tr",align:null},"\\n"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Yes"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("p",null,"Examples EXAMPLE 1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@source(type='inMemory', topic='stock', @map(type='text'))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a default text input mapping. The expected input is\nas follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'symbol:"GDN",\nprice:55.6,\nvolume:100\n')),(0,l.kt)("p",null,"OR"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"symbol:'GDN',\nprice:55.6,\nvolume:100\n")),(0,l.kt)("p",null,"If group events is enabled then input should be as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'symbol:"GDN",\nprice:55.6,\nvolume:100\n~~~~~~~~~~\nsymbol:"GDN",\nprice:55.6,\nvolume:100\n')),(0,l.kt)("p",null,"EXAMPLE 2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@source(type='inMemory', topic='stock', @map(type='text', fail.on.missing.attribute = 'true', regex.A='(\\w+)\\s([-0-9]+)',regex.B='volume\\s([-0-9]+)', @attributes(symbol = 'A[1]',price = 'A[2]',volume = 'B')))\ndefine stream FooStream (symbol string, price float, volume long);\n")),(0,l.kt)("p",null,"This query performs a custom text mapping. The expected input is as\nfollows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"wos2 550 volume 100\n")),(0,l.kt)("p",null,"If group events is enabled then input should be as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"wos2 550 volume 100\n~~~~~~~~~~\nwos2 550 volume100\n~~~~~~~~~~\nwos2 550 volume 100\n")))}d.isMDXComponent=!0}}]);